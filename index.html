<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Trail Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    #map { height: 100vh; }
  </style>
</head>
<body>
  <div id="map"></div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script>
    const map = L.map('map').setView([45.6, -73.93], 13);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '© OpenStreetMap'
    }).addTo(map);

    const trailColor = '#0077cc';
    const connectedColor = '#007744';

    let trailGraph = {};
    let allCoords = [];
    let trailLayer;

    const startIcon = new L.Icon({
      iconUrl: 'https://maps.google.com/mapfiles/ms/icons/green-dot.png',
      iconSize: [32, 32],
      iconAnchor: [16, 32],
      popupAnchor: [0, -32]
    });

    const endIcon = new L.Icon({
      iconUrl: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png',
      iconSize: [32, 32],
      iconAnchor: [16, 32],
      popupAnchor: [0, -32]
    });

    let startMarker = null;
    let endMarker = null;
    let routeLine = null;

    async function loadTrails() {
      const res = await fetch('map.geojson');
      const data = await res.json();

      trailLayer = L.geoJSON(data, {
        style: { color: trailColor }
      }).addTo(map);

      const segments = [];

      data.features.forEach(feature => {
        const coords = feature.geometry.coordinates;
        coords.forEach(c => allCoords.push([c[1], c[0]]));
        for (let i = 0; i < coords.length - 1; i++) {
          const a = coords[i];
          const b = coords[i + 1];
          const keyA = `${a[1]},${a[0]}`;
          const keyB = `${b[1]},${b[0]}`;

          if (!trailGraph[keyA]) trailGraph[keyA] = [];
          if (!trailGraph[keyB]) trailGraph[keyB] = [];

          const dist = turf.distance(turf.point(a), turf.point(b));
          trailGraph[keyA].push({ key: keyB, weight: dist });
          trailGraph[keyB].push({ key: keyA, weight: dist });

          segments.push([a, b]);
        }
      });

      connectNearbySegments(segments);
      console.log('✅ Trails loaded, graph built, nearby paths connected.');
    }

    function connectNearbySegments(segments) {
      const threshold = 0.025; // ~25 meters
      const allPoints = [];

      segments.forEach(([a, b]) => {
        allPoints.push(a, b);
      });

      const pointIndex = allPoints.map(([lng, lat]) => turf.point([lng, lat]));
      const fc = turf.featureCollection(pointIndex);

      allPoints.forEach(([lng1, lat1]) => {
        const pt = turf.point([lng1, lat1]);
        const nearby = turf.nearestPoint(pt, fc);

        if (nearby) {
          const [lng2, lat2] = nearby.geometry.coordinates;
          const key1 = `${lat1},${lng1}`;
          const key2 = `${lat2},${lng2}`;

          if (key1 !== key2) {
            const dist = turf.distance(pt, nearby);
            if (dist <= threshold) {
              if (!trailGraph[key1]) trailGraph[key1] = [];
              if (!trailGraph[key2]) trailGraph[key2] = [];
              trailGraph[key1].push({ key: key2, weight: dist });
              trailGraph[key2].push({ key: key1, weight: dist });
            }
          }
        }
      });

      console.log('✅ Nearby trail segments connected.');
    }

    function latLngStrToArr(str) {
      const [lat, lng] = str.split(',').map(parseFloat);
      return [lat, lng];
    }

    function findNearestPoint(latlng) {
      let nearest = null;
      let minDist = Infinity;
      const pt = turf.point([latlng.lng, latlng.lat]);

      for (const key in trailGraph) {
        const [lat, lng] = key.split(',').map(parseFloat);
        const dist = turf.distance(pt, turf.point([lng, lat]));
        if (dist < minDist) {
          minDist = dist;
          nearest = key;
        }
      }

      return nearest;
    }

    function dijkstra(startKey, endKey) {
      const distances = {};
      const prev = {};
      const queue = new Set(Object.keys(trailGraph));

      Object.keys(trailGraph).forEach(k => distances[k] = Infinity);
      distances[startKey] = 0;

      while (queue.size > 0) {
        let minNode = null;
        let minDist = Infinity;

        queue.forEach(node => {
          if (distances[node] < minDist) {
            minDist = distances[node];
            minNode = node;
          }
        });

        if (!minNode || minNode === endKey) break;

        queue.delete(minNode);

        trailGraph[minNode].forEach(neighbor => {
          const alt = distances[minNode] + neighbor.weight;
          if (alt < distances[neighbor.key]) {
            distances[neighbor.key] = alt;
            prev[neighbor.key] = minNode;
          }
        });
      }

      const path = [];
      let curr = endKey;
      while (curr) {
        path.unshift(curr);
        curr = prev[curr];
      }

      return path;
    }

    function renderRoute(path) {
      if (routeLine) map.removeLayer(routeLine);
      const latlngs = path.map(latLngStrToArr);
      routeLine = L.polyline(latlngs, { color: 'blue', weight: 4 }).addTo(map);
    }

    map.on('click', e => {
      const nearest = findNearestPoint(e.latlng);
      if (!nearest) return;

      if (!startMarker) {
        startMarker = L.marker(latLngStrToArr(nearest), { icon: startIcon }).addTo(map);
      } else if (!endMarker) {
        endMarker = L.marker(latLngStrToArr(nearest), { icon: endIcon }).addTo(map);
        const path = dijkstra(startMarker.getLatLng().toString(), nearest);
        renderRoute(path);
      } else {
        map.removeLayer(startMarker);
        map.removeLayer(endMarker);
        if (routeLine) map.removeLayer(routeLine);
        startMarker = L.marker(latLngStrToArr(nearest), { icon: startIcon }).addTo(map);
        endMarker = null;
      }
    });

    map.locate({ setView: false, watch: false });
    loadTrails();
  </script>
</body>
</html>
