<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interactive Trail Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 80vh; width: 100vw; }
    #info { padding: 1rem; background: #f5f5f5; }
    #route-options { margin-top: 1rem; }
    .route-option {
      margin: 4px 0;
      cursor: pointer;
      padding: 4px 8px;
      background: #e0e0e0;
      border-radius: 4px;
    }
    .route-option:hover {
      background: #d0d0d0;
    }
    #season-select {
      margin: 1rem 0;
    }
  </style>
</head>
<body>

<div id="map"></div>
<div id="info">
  <label for="season-select"><strong>Trail Filter:</strong></label>
  <select id="season-select">
    <option value="auto">Auto (Based on Date)</option>
    <option value="summer">Summer Mode</option>
    <option value="winter">Winter Mode</option>
    <option value="all">All Trails</option>
  </select><br/>
  <strong>Distance:</strong> <span id="distance">-</span> km <br />
  <strong>Estimated Time:</strong> <span id="time">-</span> min <br />
  <strong>Directions:</strong>
  <ol id="directions"></ol>
  <div id="route-options"></div>
</div>

<script>
let trailLayer = null;
let trailLayerGroup = null;
let graph = {}, nodeCoords = {}, geojsonData;
const map = L.map('map').setView([46.8, -71.2], 13);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

let startMarker = null;
let endMarker = null;
let userLocation = null;
let routeLayers = [];

function addEdge(a, b, dist) {
  if (!graph[a]) graph[a] = [];
  graph[a].push({ node: b, dist });
}

function coordKey(coord) {
  return coord[0].toFixed(5) + "," + coord[1].toFixed(5);
}

function getAllowedSeasonKeywords(mode = "auto") {
  if (mode === "all") return null;
  const keywords = ["saison"];
  if (mode === "summer") {
    keywords.push("√©t√©");
  } else if (mode === "winter") {
    keywords.push("hiver");
  } else {
    const now = new Date();
    const month = now.getMonth();
    const date = now.getDate();
    const isWinter = (month === 11 && date >= 21) || (month <= 2) || (month === 3 && date <= 30);
    keywords.push(isWinter ? "hiver" : "√©t√©");
  }
  return keywords;
}

function normalize(str) {
  return str.normalize("NFD").replace(/\p{Diacritic}/gu, "").toLowerCase();
}

function hasSeasonKeyword(name, allowedKeywords) {
  if (!allowedKeywords) return true;
  const normName = normalize(name || "");
  return allowedKeywords.some(kw => normName.includes(normalize(kw)));
}

function buildGraph(data, mode = "auto") {
  console.log("Building graph for season mode:", mode);
  const allowedKeywords = getAllowedSeasonKeywords(mode);

  graph = {};
  nodeCoords = {};
  let skipped = 0;
  let connections = 0;

  data.features.forEach(f => {
    const name = f.properties.name || f.properties.NOM || "";
    
    // üõ†Ô∏è Only skip if filtering is needed
    if (allowedKeywords && !hasSeasonKeyword(name, allowedKeywords)) {
      skipped++;
      return;
    }

    if (f.geometry.type === "LineString") {
      const coords = f.geometry.coordinates;

      for (let i = 0; i < coords.length - 1; i++) {
        const a = coords[i];
        const b = coords[i + 1];
        const aKey = coordKey(a);
        const bKey = coordKey(b);

        const dist = turf.distance(turf.point(a), turf.point(b));

        if (!graph[aKey]) graph[aKey] = [];
        if (!graph[bKey]) graph[bKey] = [];

        graph[aKey].push({ node: bKey, dist });
        graph[bKey].push({ node: aKey, dist });

        nodeCoords[aKey] = a;
        nodeCoords[bKey] = b;
        connections++;
      }
    }
  });

  console.log(`Graph built with ${connections} connections and ${skipped} skipped features.`);
}


function displayFilteredTrails() {
  // Remove old trail layer if it exists
  if (trailLayerGroup) {
    map.removeLayer(trailLayerGroup);
  }

  const allowedKeywords = getAllowedSeasonKeywords(document.getElementById('season-select').value);

  const visibleFeatures = geojsonData.features.filter(f => {
    const name = f.properties.name || f.properties.NOM || "";
    return hasSeasonKeyword(name, allowedKeywords); // ‚úÖ Apply filtering here
  });

  trailLayerGroup = L.geoJSON({ type: 'FeatureCollection', features: visibleFeatures }, {
    style: {
      color: "#3388ff",
      weight: 3
    }
  }).addTo(map);
}


function renderGeoJson(data, allowedKeywords) {
  if (window.trailsLayer) map.removeLayer(window.trailsLayer);
  window.trailsLayer = L.geoJSON(data, {
    filter: f => {
      const name = f.properties.name || f.properties.NOM || "";
      return hasSeasonKeyword(name, allowedKeywords);
    },
    style: { color: 'blue', weight: 3 }
  }).addTo(map);
}

function generateDirections(path) {
  console.log("Generating directions for path of length:", path.length);
  const instructions = [];
  for (let i = 1; i < path.length - 1; i++) {
    const prevCoord = nodeCoords[path[i - 1]];
    const currCoord = nodeCoords[path[i]];
    const nextCoord = nodeCoords[path[i + 1]];

    const prev = turf.point(prevCoord);
    const curr = turf.point(currCoord);
    const next = turf.point(nextCoord);

    const angle1 = turf.bearing(prev, curr);
    const angle2 = turf.bearing(curr, next);
    let angle = Math.abs(angle2 - angle1);
    if (angle > 180) angle = 360 - angle;

    if (angle > 30) {
      const turn = angle2 > angle1 ? "right" : "left";
      const segmentDistance = turf.distance(curr, next, { units: 'kilometers' });
      const roundedDistance = (segmentDistance * 1000).toFixed(0);
      instructions.push(`In ${roundedDistance} meters, turn ${turn}`);
    }
  }
  const dirList = document.getElementById("directions");
  dirList.innerHTML = "";
  instructions.forEach(txt => {
    const li = document.createElement("li");
    li.textContent = txt;
    dirList.appendChild(li);
  });
  return instructions;
}

function findNearestNode(latlng) {
  let nearest = null, minDist = Infinity;
  for (let key in nodeCoords) {
    const coord = nodeCoords[key];
    const dist = turf.distance(turf.point([latlng.lng, latlng.lat]), turf.point(coord));
    if (dist < minDist) {
      minDist = dist;
      nearest = key;
    }
  }
  console.log("Nearest node to", latlng, "is", nearest, "at distance", minDist);
  return nearest;
}


function addTemporaryNodeToGraph(snappedPoint) {
  const tempKey = coordKey([snappedPoint.lng, snappedPoint.lat]);

  let closestSegment = null;
  let minDist = Infinity;

  // Look for a segment in the GRAPH, not just in all trail data
  for (const aKey in graph) {
    for (const edge of graph[aKey]) {
      const bKey = edge.node;

      const a = nodeCoords[aKey];
      const b = nodeCoords[bKey];

      if (!a || !b) continue;

      const line = turf.lineString([a, b]);
      const dist = turf.pointToLineDistance(
        turf.point([snappedPoint.lng, snappedPoint.lat]),
        line,
        { units: 'kilometers' }
      );

      if (dist < minDist) {
        minDist = dist;
        closestSegment = { a, b, aKey, bKey };
      }
    }
  }

  if (closestSegment) {
    const { a, b, aKey, bKey } = closestSegment;
    const distToA = turf.distance(turf.point(a), turf.point([snappedPoint.lng, snappedPoint.lat]));
    const distToB = turf.distance(turf.point(b), turf.point([snappedPoint.lng, snappedPoint.lat]));

    graph[tempKey] = [
      { node: aKey, dist: distToA },
      { node: bKey, dist: distToB }
    ];

    // Reverse connections
    graph[aKey].push({ node: tempKey, dist: distToA });
    graph[bKey].push({ node: tempKey, dist: distToB });

    // Store the actual coordinates
    nodeCoords[tempKey] = [snappedPoint.lng, snappedPoint.lat];
  } else {
    console.warn("‚ùå No nearby segment found in graph to snap to.");
  }

  return tempKey;
}




  function addSnappedPointToGraph(latlng) {
  const pt = turf.point([latlng.lng, latlng.lat]);
  let minDist = Infinity;
  let snappedCoord = null;
  let segmentEnds = [];

  geojsonData.features.forEach(f => {
    if (f.geometry.type === "LineString") {
      const line = turf.lineString(f.geometry.coordinates);
      const snapped = turf.nearestPointOnLine(line, pt);
      if (snapped.properties.dist < minDist) {
        minDist = snapped.properties.dist;
        snappedCoord = snapped.geometry.coordinates;

        const segIndex = snapped.properties.index;
        const coords = f.geometry.coordinates;

        if (segIndex < coords.length - 1) {
          segmentEnds = [coords[segIndex], coords[segIndex + 1]];
        }
      }
    }
  });

  if (!snappedCoord || segmentEnds.length !== 2) {
    console.warn("Snapping failed.");
    return null;
  }

  const keySnapped = coordKey(snappedCoord);
  nodeCoords[keySnapped] = snappedCoord;

  const [a, b] = segmentEnds;
  const keyA = coordKey(a);
  const keyB = coordKey(b);

  // Add bidirectional edges to the graph
  const distA = turf.distance(turf.point(a), turf.point(snappedCoord));
  const distB = turf.distance(turf.point(b), turf.point(snappedCoord));
  addEdge(keyA, keySnapped, distA);
  addEdge(keySnapped, keyA, distA);
  addEdge(keyB, keySnapped, distB);
  addEdge(keySnapped, keyB, distB);

  return keySnapped;
}


function dijkstra(startKey, endKey) {
  console.log("Running Dijkstra from", startKey, "to", endKey);
  const dist = {}, prev = {}, visited = new Set();
  dist[startKey] = 0;

  let iterations = 0, maxIterations = 20000;
  const queue = new Set([startKey]);

  while (queue.size > 0 && iterations++ < maxIterations) {
    let u = null;
    let minDist = Infinity;

    for (let node of queue) {
      if (dist[node] < minDist) {
        minDist = dist[node];
        u = node;
      }
    }

    if (!u) break;
    queue.delete(u);

    if (iterations % 1000 === 0) {
      console.log(`Iteration ${iterations}, visiting ${u}, dist=${dist[u]}`);
    }

    if (u === endKey) break;

    visited.add(u);
    for (let neighbor of (graph[u] || [])) {
      if (visited.has(neighbor.node)) continue;
      const alt = dist[u] + neighbor.dist;
      if (alt < (dist[neighbor.node] || Infinity)) {
        dist[neighbor.node] = alt;
        prev[neighbor.node] = u;
        queue.add(neighbor.node);
      }
    }
  }

  if (iterations >= maxIterations) {
    console.warn("‚ùå Dijkstra aborted: too many iterations or disconnected graph.");
    alert("‚ö†Ô∏è Route search failed: too many steps. This might be due to disconnected trails.");
    return [];
  }

  const path = [];
  let u = endKey;
  while (u) {
    path.unshift(u);
    u = prev[u];
  }

  if (path[0] !== startKey) {
    console.warn("‚ùå No path could be reconstructed from", startKey, "to", endKey);
    alert("‚ö†Ô∏è Unable to reconstruct route. Trails might be disconnected.");
    return [];
  }

  console.log("‚úÖ Dijkstra finished. Path length:", path.length);
  return path;
}


function drawRoute(path) {
  console.log("Drawing route with", path.length, "points.");
  
  // Clear previous route layers
  routeLayers.forEach(l => map.removeLayer(l));
  routeLayers = [];

  const coords = path.map(k => {
    const coord = nodeCoords[k];

    if (!coord) {
      console.warn("Missing nodeCoords for key:", k);
      return null;
    }

    // Normalize to [lat, lng] format for Leaflet
    if (Array.isArray(coord)) {
      // coord is [lng, lat] or [lng, lat, ...]
      const lng = coord[0];
      const lat = coord[1];
      return [lat, lng];
    }

    // If somehow stored as GeoJSON Point
    if (coord.type === "Point" && Array.isArray(coord.coordinates)) {
      const [lng, lat] = coord.coordinates;
      return [lat, lng];
    }

    console.warn("Invalid coordinate format for key:", k, "‚Üí", coord);
    return null;
  }).filter(Boolean);

  console.log("Route coordinates:", coords);

  if (coords.length < 2) {
    console.warn("Not enough valid coordinates to draw route.");
    return;
  }

  // Draw route
  const line = L.polyline(coords, { color: 'orange', weight: 4 }).addTo(map);
  routeLayers.push(line);

  // Calculate and display distance and estimated time
  const totalDist = coords.reduce((sum, _, i) => {
    if (i === 0) return 0;
    return sum + turf.distance(turf.point([coords[i - 1][1], coords[i - 1][0]]), turf.point([coords[i][1], coords[i][0]]));
  }, 0);

  document.getElementById("distance").textContent = totalDist.toFixed(2);
  document.getElementById("time").textContent = Math.round((totalDist / 5) * 60); // 5 km/h
}



map.on("click", e => {
  console.log("Map clicked at", e.latlng);

  const clickPoint = turf.point([e.latlng.lng, e.latlng.lat]);
  const allowedKeywords = getAllowedSeasonKeywords(document.getElementById('season-select').value);

  let minDist = Infinity;
  let snappedPoint = null;

  // Step 1: Filter features by season and snap click to nearest trail
  const filteredFeatures = geojsonData.features.filter(f => {
    const name = f.properties.name || f.properties.NOM || "";
    return hasSeasonKeyword(name, allowedKeywords);
  });

  filteredFeatures.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const line = turf.lineString(f.geometry.coordinates);
      const candidate = turf.nearestPointOnLine(line, clickPoint, { units: 'kilometers' });
      const dist = turf.pointToLineDistance(clickPoint, line, { units: 'kilometers' });

      if (dist < minDist) {
        minDist = dist;
        snappedPoint = candidate;
      }
    }
  });

  if (!snappedPoint) {
    alert("‚ùå No nearby trail segment found.");
    return;
  }

  const snappedLatLng = L.latLng(
    snappedPoint.geometry.coordinates[1],
    snappedPoint.geometry.coordinates[0]
  );

  if (!startMarker) {
    startMarker = L.marker(snappedLatLng, {
      draggable: false,
      icon: L.icon({
        iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/green-dot.png',
        iconSize: [32, 32],
        iconAnchor: [16, 32]
      })
    }).addTo(map);
  } else if (!endMarker) {
    endMarker = L.marker(snappedLatLng, {
      draggable: false,
      icon: L.icon({
        iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/red-dot.png',
        iconSize: [32, 32],
        iconAnchor: [16, 32]
      })
    }).addTo(map);

    // ‚úÖ Use same filtered trails for snapping to graph nodes
    const snappedStart = turf.nearestPointOnLine(
      turf.featureCollection(filteredFeatures),
      turf.point([startMarker.getLatLng().lng, startMarker.getLatLng().lat])
    );
    const snappedEnd = turf.nearestPointOnLine(
      turf.featureCollection(filteredFeatures),
      turf.point([endMarker.getLatLng().lng, endMarker.getLatLng().lat])
    );

    const snappedStartCoords = [snappedStart.geometry.coordinates[0], snappedStart.geometry.coordinates[1]];
    const snappedEndCoords = [snappedEnd.geometry.coordinates[0], snappedEnd.geometry.coordinates[1]];

    const startKey = addTemporaryNodeToGraph({ lat: snappedStartCoords[1], lng: snappedStartCoords[0] });
    const endKey = addTemporaryNodeToGraph({ lat: snappedEndCoords[1], lng: snappedEndCoords[0] });

    if (!graph[startKey]) {
      graph[startKey] = findNearestGraphConnections(snappedStartCoords);
      nodeCoords[startKey] = snappedStartCoords;
    }
    if (!graph[endKey]) {
      graph[endKey] = findNearestGraphConnections(snappedEndCoords);
      nodeCoords[endKey] = snappedEndCoords;
    }

    const path = dijkstra(startKey, endKey);

    if (path.length > 0) {
      drawRoute(path);
    } else {
      alert("No path found.");
      console.warn("No path found between", startKey, "and", endKey);
    }
  } else {
    map.removeLayer(startMarker);
    map.removeLayer(endMarker);
    startMarker = null;
    endMarker = null;
    routeLayers.forEach(l => map.removeLayer(l));
    routeLayers = [];
    document.getElementById("distance").textContent = "-";
    document.getElementById("time").textContent = "-";
    document.getElementById("directions").innerHTML = "";
  }
});


navigator.geolocation.getCurrentPosition(pos => {
  userLocation = [pos.coords.latitude, pos.coords.longitude];
  L.marker(userLocation).addTo(map).bindPopup("You are here").openPopup();
  map.setView(userLocation, 14);
});

fetch('map.geojson')
  .then(res => res.json())
  .then(data => {
    geojsonData = data;
    const dropdown = document.getElementById('season-select');

    dropdown.addEventListener('change', () => {
      console.log("Season dropdown changed to:", dropdown.value);
      buildGraph(geojsonData, dropdown.value);
      displayFilteredTrails(); // <--- ADDED: redraw visible trails
    });

    buildGraph(data, dropdown.value);   // build routing graph
    displayFilteredTrails();            // <--- ADDED: draw trails initially
  })
  .catch(err => console.error("Failed to load map data:", err));

  
</script>

</body>
</html>
