<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interactive Trail Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 80vh; width: 100vw; }
    #info { padding: 1rem; background: #f5f5f5; }
  </style>
</head>
<body>

<div id="map"></div>
<div id="info">
  <strong>Distance:</strong> <span id="distance">-</span> km <br />
  <strong>Estimated Time:</strong> <span id="time">-</span> min <br />
  <strong>Directions:</strong>
  <ol id="directions"></ol>
</div>

<script>
let map = L.map('map', { doubleClickZoom: false }).setView([45.6362, -74.0345], 15);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

let trailData, graph = {}, nodeCoords = {};
let startMarker, endMarker, clickCount = 0, startNode = null, endNode = null;
let userMarker;
let routeLines = [];

function coordKey(coord) {
  return `${coord[1].toFixed(5)},${coord[0].toFixed(5)}`;
}

function addEdge(a, b, dist) {
  if (!graph[a]) graph[a] = [];
  graph[a].push({ node: b, dist });
}

function buildGraph(data) {
  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        const a = coordKey(coords[i]);
        const b = coordKey(coords[i + 1]);
        const dist = turf.distance(turf.point(coords[i]), turf.point(coords[i + 1]));
        addEdge(a, b, dist);
        addEdge(b, a, dist);
        nodeCoords[a] = coords[i];
        nodeCoords[b] = coords[i + 1];
      }
    }
  });
}

function connectNearbySegments(data, threshold = 25) {
  const lineSegments = [];
  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        lineSegments.push([coords[i], coords[i + 1]]);
      }
    }
  });
  for (let i = 0; i < lineSegments.length; i++) {
    for (let j = i + 1; j < lineSegments.length; j++) {
      const line1 = turf.lineString(lineSegments[i]);
      const line2 = turf.lineString(lineSegments[j]);
      const options = { units: 'meters' };
      const dist = turf.pointToLineDistance(turf.midpoint(line1.geometry.coordinates[0], line1.geometry.coordinates[1]), line2, options);
      if (dist <= threshold) {
        const pt1 = turf.nearestPointOnLine(line2, turf.midpoint(line1.geometry.coordinates[0], line1.geometry.coordinates[1]));
        const pt2 = turf.nearestPointOnLine(line1, turf.midpoint(line2.geometry.coordinates[0], line2.geometry.coordinates[1]));
        const a = coordKey(pt1.geometry.coordinates);
        const b = coordKey(pt2.geometry.coordinates);
        const distBetween = turf.distance(pt1, pt2, { units: 'kilometers' });
        nodeCoords[a] = pt1.geometry.coordinates;
        nodeCoords[b] = pt2.geometry.coordinates;
        addEdge(a, b, distBetween);
        addEdge(b, a, distBetween);
      }
    }
  }
}

function findClosestNode(latLng) {
  let minDist = Infinity;
  let closestNode = null;
  const threshold = 100;
  Object.keys(nodeCoords).forEach(key => {
    const nodeLatLng = L.latLng(nodeCoords[key][1], nodeCoords[key][0]);
    const dist = latLng.distanceTo(nodeLatLng);
    if (dist < minDist && dist <= threshold) {
      minDist = dist;
      closestNode = key;
    }
  });
  return closestNode;
}

function findAllPaths(start, end) {
  const allPaths = [];
  function dfs(current, path, visited, distance) {
    if (current === end) {
      allPaths.push({ path: [...path, current], distance });
      return;
    }
    visited.add(current);
    if (graph[current]) {
      for (const neighbor of graph[current]) {
        if (!visited.has(neighbor.node)) {
          dfs(neighbor.node, [...path, current], new Set(visited), distance + neighbor.dist);
        }
      }
    }
  }
  dfs(start, [], new Set(), 0);
  return allPaths.sort((a, b) => a.distance - b.distance);
}

function renderRoutes(paths) {
  routeLines.forEach(line => map.removeLayer(line));
  routeLines = [];
  const directionsList = document.getElementById('directions');
  directionsList.innerHTML = '';
  let totalDistance = 0;
  paths.forEach((route, i) => {
    const coords = route.path.map(n => [nodeCoords[n][1], nodeCoords[n][0]]);
    const line = L.polyline(coords, { color: i === 0 ? 'green' : 'gray', weight: 5, opacity: 0.7 }).addTo(map);
    routeLines.push(line);
    const li = document.createElement('li');
    li.textContent = `Route ${i + 1}: ${route.distance.toFixed(2)} km`;
    directionsList.appendChild(li);
    if (i === 0) totalDistance = route.distance;
  });
  document.getElementById('distance').textContent = totalDistance.toFixed(2);
  document.getElementById('time').textContent = Math.round(totalDistance * 12);
}

fetch('map.geojson')
  .then(res => res.json())
  .then(data => {
    trailData = data;
    L.geoJSON(data, { color: 'blue' }).addTo(map);
    buildGraph(data);
    connectNearbySegments(data);
  });

const greenIcon = L.icon({
  iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
  iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
});
const redIcon = L.icon({
  iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
  iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
});

map.on('click', function (e) {
  const snapped = findClosestNode(e.latlng);
  if (!snapped) return alert("No nearby trail found.");
  const snappedLatLng = L.latLng(nodeCoords[snapped][1], nodeCoords[snapped][0]);
  if (clickCount === 0) {
    if (startMarker) map.removeLayer(startMarker);
    startMarker = L.marker(snappedLatLng, { icon: greenIcon }).addTo(map);
    startNode = snapped;
    clickCount++;
  } else {
    if (endMarker) map.removeLayer(endMarker);
    endMarker = L.marker(snappedLatLng, { icon: redIcon }).addTo(map);
    endNode = snapped;
    clickCount = 0;
    const paths = findAllPaths(startNode, endNode);
    if (paths.length === 0) return alert("No route found.");
    renderRoutes(paths);
  }
});
</script>
</body>
</html>
