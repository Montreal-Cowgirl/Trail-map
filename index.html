<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interactive Trail Map v1.002</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 80vh; width: 100vw; }
    #info { padding: 1rem; background: #f5f5f5; }
    #route-options { margin-top: 1rem; }
    .route-option {
      margin: 4px 0;
      cursor: pointer;
      padding: 4px 8px;
      background: #e0e0e0;
      border-radius: 4px;
    }
    .route-option:hover {
      background: #d0d0d0;
    }
  </style>
</head>
<body>

<div id="map"></div>

<div id="info">
  <label for="trailFilter"><strong>Trail Mode:</strong></label>
  <select id="trailFilter">
    <option value="all">All</option>
    <option value="ete">Été + Saison</option>
    <option value="hiver">Hiver + Saison</option>
  </select>
  <br /><br />

  <strong>Distance:</strong> <span id="distance">-</span> km <br />
  <strong>Estimated Time:</strong> <span id="time">-</span> min <br />
  <strong>Directions:</strong>
  <ol id="directions"></ol>
  <div id="route-options"></div>
</div>

<script>
let map = L.map('map', { doubleClickZoom: false }).setView([45.6362, -74.0345], 15);
// Request and show user location with a marker
map.locate({ setView: true, maxZoom: 16 });

function onLocationFound(e) {
  const radius = e.accuracy;
  const userMarker = L.marker(e.latlng)
    .addTo(map)
    .bindPopup("You are here")
    .openPopup();

  // Optional: show accuracy circle
  // L.circle(e.latlng, radius).addTo(map);
}

function onLocationError(e) {
  alert("Location access denied or unavailable.");
}

map.on('locationfound', onLocationFound);
map.on('locationerror', onLocationError);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);
let originalTrailData = null;
let filteredLayer = null;
let graph = {}, nodeCoords = {};
let startMarker=null, endMarker=null, clickCount = 0, startNode = null, endNode = null;
let routeLine=null, previewLines = [];

const trailFilterSelect = document.getElementById('trailFilter');
const startIcon = L.icon({
  iconUrl: 'https://maps.google.com/mapfiles/ms/icons/green-dot.png',
  iconSize: [32, 32],
  iconAnchor: [16, 32]
});

const endIcon = L.icon({
  iconUrl: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png',
  iconSize: [32, 32],
  iconAnchor: [16, 32]
});

function coordKey(coord) {
  return `${coord[1].toFixed(5)},${coord[0].toFixed(5)}`;
}

function addEdge(a, b, dist) {
  if (!graph[a]) graph[a] = [];
  graph[a].push({ node: b, dist });
}

function buildGraph(data) {
  graph = {};
  nodeCoords = {};

  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        const a = coordKey(coords[i]);
        const b = coordKey(coords[i + 1]);
        const dist = turf.distance(turf.point(coords[i]), turf.point(coords[i + 1]));
        addEdge(a, b, dist);
        addEdge(b, a, dist);
        nodeCoords[a] = coords[i];
        nodeCoords[b] = coords[i + 1];
      }
    }
  });
}

function connectNearbySegments(data, threshold = 25) {
  const lineSegments = [];
  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        lineSegments.push([coords[i], coords[i + 1]]);
      }
    }
  });

  for (let i = 0; i < lineSegments.length; i++) {
    for (let j = i + 1; j < lineSegments.length; j++) {
      const line1 = turf.lineString(lineSegments[i]);
      const line2 = turf.lineString(lineSegments[j]);
      const dist = turf.pointToLineDistance(
        turf.midpoint(line1.geometry.coordinates[0], line1.geometry.coordinates[1]),
        line2,
        { units: 'meters' }
      );
      if (dist <= threshold) {
        const pt1 = turf.nearestPointOnLine(line2, turf.midpoint(...line1.geometry.coordinates));
        const pt2 = turf.nearestPointOnLine(line1, turf.midpoint(...line2.geometry.coordinates));
        const a = coordKey(pt1.geometry.coordinates);
        const b = coordKey(pt2.geometry.coordinates);
        const distBetween = turf.distance(pt1, pt2, { units: 'kilometers' });
        nodeCoords[a] = pt1.geometry.coordinates;
        nodeCoords[b] = pt2.geometry.coordinates;
        addEdge(a, b, distBetween);
        addEdge(b, a, distBetween);
      }
    }
  }
}
function updateTrailDisplay(mode) {
  if (filteredLayer) map.removeLayer(filteredLayer);
  graph = {};
  nodeCoords = {};

  const filtered = {
    type: "FeatureCollection",
    features: originalTrailData.features.filter(f => {
      const rawName = f.properties.name || "";
      const name = rawName
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .toLowerCase();

      const hasEte = name.includes("ete");
      const hasHiver = name.includes("hiver");
      const hasSaison = name.includes("saison");

      if (mode === "all") return true;
      if (mode === "ete") return hasEte || hasSaison;
      if (mode === "hiver") return hasHiver || hasSaison;

      return false;
    })
  };

  filteredLayer = L.geoJSON(filtered, { color: 'blue' }).addTo(map);
  buildGraph(filtered);
  connectNearbySegments(filtered, 25);
}

  
function filterTrails(mode) {
  const normalize = s => s.normalize('NFD').replace(/[\u0300-\u036f]/g, "").toLowerCase();

  return {
    type: 'FeatureCollection',
    features: originalTrailData.features.filter(f => {
      const rawName = f.properties.name || "";
      const name = rawName
        .normalize("NFD")                 // Normalize accents
        .replace(/[\u0300-\u036f]/g, "") // Strip accents
        .toLowerCase();
    
      const hasEte = name.includes("ete");
      const hasHiver = name.includes("hiver");
      const hasSaison = name.includes("saison");
    
      if (mode === "all") return true;
      if (mode === "ete") return hasEte || hasSaison;
      if (mode === "hiver") return hasHiver || hasSaison;
    
      return false;
    })
  };
}


function renderTrails(data) {
  if (filteredLayer) map.removeLayer(filteredLayer);
  filteredLayer = L.geoJSON(data, { color: 'blue' }).addTo(map);
}

function rebuildTrailNetwork(mode) {
  const filtered = filterTrails(mode);
  renderTrails(filtered);
  buildGraph(filtered);
  connectNearbySegments(filtered, 25);
}

function findClosestNode(latLng) {
  let minDist = Infinity, closestNode = null, threshold = 100;
  Object.keys(nodeCoords).forEach(key => {
    const nodeLatLng = L.latLng(nodeCoords[key][1], nodeCoords[key][0]);
    const dist = latLng.distanceTo(nodeLatLng);
    if (dist < minDist && dist <= threshold) {
      minDist = dist;
      closestNode = key;
    }
  });
  return closestNode;
}

trailFilterSelect.addEventListener('change', () => {
  rebuildTrailNetwork(trailFilterSelect.value);
  clickCount = 0;
  if (startMarker) map.removeLayer(startMarker);
  if (endMarker) map.removeLayer(endMarker);
  if (routeLine) map.removeLayer(routeLine);
  previewLines.forEach(l => map.removeLayer(l));
  previewLines = [];
  document.getElementById('directions').innerHTML = '';
  document.getElementById('distance').textContent = '-';
  document.getElementById('time').textContent = '-';
  document.getElementById('route-options').innerHTML = '';
});

let clickState = 0;
let trailLine;
  
map.on('click', function (e) {
  const latlng = e.latlng;

  // Reset everything after second click
  if (clickState === 2) {
    if (startMarker) map.removeLayer(startMarker);
    if (endMarker) map.removeLayer(endMarker);
    if (routeLine) map.removeLayer(routeLine);
    previewLines.forEach(line => map.removeLayer(line));
    previewLines = [];
    document.getElementById('route-options').innerHTML = '';
    document.getElementById('directions').innerHTML = '';
    document.getElementById('distance').textContent = '-';
    document.getElementById('time').textContent = '-';
    startMarker = null;
    endMarker = null;
    startNode = null;
    endNode = null;
    clickState = 0;
    return;
  }

    if (!trailLine) {
    console.warn("Trail line not loaded yet.");
    return;
  }

  // Snap click to nearest point on a trail
  const snapped = turf.nearestPointOnLine(trailLine, turf.point([latlng.lng, latlng.lat]));
  const snappedCoords = snapped.geometry.coordinates;
  const snappedLatLng = L.latLng(snappedCoords[1], snappedCoords[0]);
  const nearestNode = findClosestNode(snappedLatLng);

  if (clickState === 0) {
    // Place start marker
    startMarker = L.marker(snappedLatLng, { icon: startIcon }).addTo(map);
    startNode = nearestNode;
    clickState = 1;
  } else if (clickState === 1) {
    // Place end marker
    endMarker = L.marker(snappedLatLng, { icon: endIcon }).addTo(map);
    endNode = nearestNode;

    if (!startNode || !endNode) {
      alert("Could not find a nearby trail node.");
      return;
    }
    
    const routes = findMultipleRoutes(startNode, endNode);
    renderRouteOptions(routes);
    clickState = 2;
  }
});

function findPath(graph, startNodeId, endNodeId, blockedEdges) {
  const queue = new TinyQueue([], (a, b) => a.priority - b.priority);
  const visited = new Set();
  const cameFrom = {};
  const costSoFar = {};
  queue.push({ node: startNodeId, priority: 0 });
  costSoFar[startNodeId] = 0;

  while (queue.length) {
    const current = queue.pop().node;

    if (current === endNodeId) break;

    if (!graph.nodes[current]) continue;

    for (const neighbor of graph.nodes[current]) {
      const edgeId = graph.edgeMap[`${current}-${neighbor.id}`] || graph.edgeMap[`${neighbor.id}-${current}`];
      if (blockedEdges.has(edgeId)) continue;

      const newCost = costSoFar[current] + neighbor.weight;
      if (costSoFar[neighbor.id] === undefined || newCost < costSoFar[neighbor.id]) {
        costSoFar[neighbor.id] = newCost;
        const priority = newCost + heuristic(graph.positions[neighbor.id], graph.positions[endNodeId]);
        queue.push({ node: neighbor.id, priority });
        cameFrom[neighbor.id] = current;
      }
    }
  }

  const path = [];
  let current = endNodeId;
  while (current !== startNodeId) {
    if (!(current in cameFrom)) return null;
    path.push(current);
    current = cameFrom[current];
  }
  path.push(startNodeId);
  path.reverse();
  return path;
}

  
function findMultipleRoutes(startNodeId, endNodeId) {
    const maxRoutes = 5;
    const angleThreshold = 10; // degrees
    const uniquenessThreshold = 5; // meters
    const minRouteLength = 30; // meters

    let allRoutes = [];
    let blockedEdges = new Set();

    for (let i = 0; i < maxRoutes; i++) {
        const graph = buildGraph(); // ensure graph is rebuilt every time
        const route = findPath(graph, startNodeId, endNodeId, blockedEdges);
        if (!route || route.length < 2) break;

        const routeCoords = route.map(nodeId => nodeCoordinates[nodeId]);
        const length = calculatePathLength(routeCoords);
        if (length < minRouteLength) break;

        // Check uniqueness against previous routes
        let isUnique = true;
        for (const otherRoute of allRoutes) {
            const otherCoords = otherRoute.map(nodeId => nodeCoordinates[nodeId]);
            const distance = comparePaths(routeCoords, otherCoords);
            if (distance < uniquenessThreshold) {
                isUnique = false;
                break;
            }
        }

        if (isUnique) {
            allRoutes.push(route);

            // Block one edge at turning point
            const turningIndex = findTurningPoint(routeCoords, angleThreshold);
            if (turningIndex !== -1 && turningIndex < route.length - 1) {
                const a = route[turningIndex];
                const b = route[turningIndex + 1];
                blockedEdges.add(`${a}-${b}`);
                blockedEdges.add(`${b}-${a}`);
            } else {
                break;
            }
        } else {
            break;
        }
    }

    renderRoutes(allRoutes);
}


function renderRouteOptions(routes) {
  const routeOptionsDiv = document.getElementById('route-options');
  routeOptionsDiv.innerHTML = '';
  previewLines.forEach(line => map.removeLayer(line));
  previewLines = [];

  routes.forEach((route, idx) => {
    const routeCoords = route.map(node => [nodeCoords[node][1], nodeCoords[node][0]]);
    const totalDist = route.reduce((sum, node, i) => {
      if (i < route.length - 1) {
        return sum + turf.distance(turf.point(nodeCoords[node]), turf.point(nodeCoords[route[i + 1]]));
      }
      return sum;
    }, 0);

    const colors = ['orange', 'purple', 'hotpink'];
    const line = L.polyline(routeCoords, { color: colors[idx % colors.length], weight: 4, dashArray: '5, 5' }).addTo(map);
    previewLines.push(line);

    const routeOption = document.createElement('div');
    routeOption.classList.add('route-option');
    routeOption.textContent = `Route ${idx + 1}: ${totalDist.toFixed(2)} km`;

    routeOption.onclick = () => {
      previewLines.forEach(line => map.removeLayer(line));
      renderRoute(route);
      renderDirections(route);
    };

    routeOptionsDiv.appendChild(routeOption);
  });
}

function renderRoute(path) {
  const routeCoords = path.map(node => [nodeCoords[node][1], nodeCoords[node][0]]);
  if (routeLine) map.removeLayer(routeLine);
  routeLine = L.polyline(routeCoords, { color: 'green', weight: 5 }).addTo(map);
}

function renderDirections(path) {
  const directionsList = document.getElementById('directions');
  directionsList.innerHTML = '';
  let totalDistance = 0, prevBearing = null, distanceSinceLastTurn = 0;

  path.forEach((node, idx) => {
    if (idx < path.length - 1) {
      const from = nodeCoords[node], to = nodeCoords[path[idx + 1]];
      const dist = turf.distance(turf.point(from), turf.point(to));
      totalDistance += dist;
      distanceSinceLastTurn += dist;
      const bearing = turf.bearing(turf.point(from), turf.point(to));
      if (prevBearing !== null) {
        let angleChange = bearing - prevBearing;
        if (angleChange > 180) angleChange -= 360;
        if (angleChange < -180) angleChange += 360;
        const absChange = Math.abs(angleChange);
        if (absChange > 25) {
          let direction = '';
          if (absChange > 135) direction = 'Make a U-turn';
          else if (absChange > 90) direction = angleChange > 0 ? 'Turn sharply right' : 'Turn sharply left';
          else if (absChange > 30) direction = angleChange > 0 ? 'Turn right' : 'Turn left';
          else direction = angleChange > 0 ? 'Slight right' : 'Slight left';

          const li = document.createElement('li');
          li.textContent = `${direction} in ${Math.round(distanceSinceLastTurn * 1000)}m`;
          directionsList.appendChild(li);
          distanceSinceLastTurn = 0;
        }
      }
      prevBearing = bearing;
    }
  });

  document.getElementById('distance').textContent = totalDistance.toFixed(2);
  document.getElementById('time').textContent = Math.round(totalDistance * 12);
}

fetch('map.geojson')
  .then(res => res.json())
  .then(data => {
    originalTrailData = data;
    trailLine = turf.lineString(
      data.features
      .filter(f => f.geometry.type === 'LineString')
      .flatMap(f => f.geometry.coordinates)
    );

    updateTrailDisplay('all'); // initial render
  });


</script>

</body>
</html>
