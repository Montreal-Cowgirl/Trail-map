<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interactive Trail Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 80vh; width: 100vw; }
    #info { padding: 1rem; background: #f5f5f5; }
    #route-options { margin-top: 1rem; }
    .route-option {
      margin: 4px 0;
      cursor: pointer;
      padding: 4px 8px;
      background: #e0e0e0;
      border-radius: 4px;
    }
    .route-option:hover {
      background: #d0d0d0;
    }
  </style>
</head>
<body>

<div id="map"></div>
<div id="info">
  <strong>Distance:</strong> <span id="distance">-</span> km <br />
  <strong>Estimated Time:</strong> <span id="time">-</span> min <br />
  <strong>Directions:</strong>
  <ol id="directions"></ol>
  <div id="route-options"></div>
</div>

<script>
let map = L.map('map', { doubleClickZoom: false }).setView([45.6362, -74.0345], 15);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

let trailData, graph = {}, nodeCoords = {};
let startMarker, endMarker, clickCount = 0, startNode = null, endNode = null;
let previewLines = [], routeLine;

function coordKey(coord) {
  return `${coord[1].toFixed(5)},${coord[0].toFixed(5)}`;
}

function addEdge(a, b, dist) {
  if (!graph[a]) graph[a] = [];
  graph[a].push({ node: b, dist });
}

function buildGraph(data) {
  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        const a = coordKey(coords[i]);
        const b = coordKey(coords[i + 1]);
        const dist = turf.distance(turf.point(coords[i]), turf.point(coords[i + 1]));
        addEdge(a, b, dist);
        addEdge(b, a, dist);
        nodeCoords[a] = coords[i];
        nodeCoords[b] = coords[i + 1];
      }
    }
  });
}

function connectNearbySegments(data, threshold = 25) {
  const lineSegments = [];
  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        lineSegments.push([coords[i], coords[i + 1]]);
      }
    }
  });

  for (let i = 0; i < lineSegments.length; i++) {
    for (let j = i + 1; j < lineSegments.length; j++) {
      const mid1 = turf.midpoint(...lineSegments[i]);
      const mid2 = turf.midpoint(...lineSegments[j]);
      const dist = turf.distance(mid1, mid2, { units: 'meters' });

      if (dist <= threshold) {
        const pt1 = turf.nearestPointOnLine(turf.lineString(lineSegments[j]), mid1);
        const pt2 = turf.nearestPointOnLine(turf.lineString(lineSegments[i]), mid2);
        const a = coordKey(pt1.geometry.coordinates);
        const b = coordKey(pt2.geometry.coordinates);
        const distBetween = turf.distance(pt1, pt2, { units: 'kilometers' });

        nodeCoords[a] = pt1.geometry.coordinates;
        nodeCoords[b] = pt2.geometry.coordinates;
        addEdge(a, b, distBetween);
        addEdge(b, a, distBetween);
      }
    }
  }
}

function findClosestNode(latLng) {
  let minDist = Infinity, closestNode = null, threshold = 100;
  Object.keys(nodeCoords).forEach(key => {
    const nodeLatLng = L.latLng(nodeCoords[key][1], nodeCoords[key][0]);
    const dist = latLng.distanceTo(nodeLatLng);
    if (dist < minDist && dist <= threshold) {
      minDist = dist;
      closestNode = key;
    }
  });
  return closestNode;
}

fetch('map.geojson')
  .then(res => res.json())
  .then(data => {
    trailData = data;
    L.geoJSON(data, { color: 'blue' }).addTo(map);
    buildGraph(data);
    connectNearbySegments(data, 25);
  });

map.on('click', function (e) {
  const snapped = findClosestNode(e.latlng);
  if (!snapped) return alert("No nearby trail found.");
  const snappedLatLng = L.latLng(nodeCoords[snapped][1], nodeCoords[snapped][0]);

  const greenIcon = new L.Icon.Default();
  const redIcon = new L.Icon.Default();

  if (clickCount === 0) {
    if (startMarker) map.removeLayer(startMarker);
    startMarker = L.marker(snappedLatLng, { icon: greenIcon }).addTo(map);
    startNode = snapped;
    clickCount++;
  } else {
    if (endMarker) map.removeLayer(endMarker);
    endMarker = L.marker(snappedLatLng, { icon: redIcon }).addTo(map);
    endNode = snapped;
    clickCount = 0;
    const routes = findMultipleRoutes(startNode, endNode, 3);
    if (!routes || routes.length === 0) return alert("No path found.");
    renderRouteOptions(routes);
  }
});

// Improved: prevent early detours from initial route
function findMultipleRoutes(start, end, numRoutes = 3) {
  const allPaths = [], visitedPaths = new Set();

  function dijkstra(blockedEdges = [], lockedPrefix = []) {
    const distances = {}, previous = {}, pq = new Set(Object.keys(graph));
    const blockedSet = new Set(blockedEdges.map(e => `${e[0]}->${e[1]}`));
    Object.keys(graph).forEach(n => distances[n] = Infinity);
    distances[start] = 0;

    while (pq.size) {
      const current = [...pq].reduce((a, b) => distances[a] < distances[b] ? a : b);
      if (current === end) break;
      pq.delete(current);
      for (const neighbor of graph[current] || []) {
        const edge = `${current}->${neighbor.node}`;
        if (blockedSet.has(edge)) continue;
        const alt = distances[current] + neighbor.dist;
        if (alt < distances[neighbor.node]) {
          distances[neighbor.node] = alt;
          previous[neighbor.node] = current;
        }
      }
    }

    const path = [];
    let curr = end;
    while (previous[curr]) {
      path.unshift(curr);
      curr = previous[curr];
    }
    if (curr === start) {
      path.unshift(start);
      // Prevent jumps within the first 3 nodes
      for (let i = 0; i < lockedPrefix.length; i++) {
        if (path[i] !== lockedPrefix[i]) return [];
      }
      return path;
    }
    return [];
  }

  const firstPath = dijkstra();
  if (!firstPath.length) return allPaths;
  allPaths.push(firstPath);
  visitedPaths.add(firstPath.join('->'));

  const lockedPrefix = firstPath.slice(0, 3); // lock early path

  for (let i = 1; i < firstPath.length - 1 && allPaths.length < numRoutes; i++) {
    const blocked = [[firstPath[i], firstPath[i + 1]]];
    const newPath = dijkstra(blocked, lockedPrefix);
    const key = newPath.join('->');
    if (newPath.length && !visitedPaths.has(key)) {
      allPaths.push(newPath);
      visitedPaths.add(key);
    }
  }

  return allPaths;
}

function renderRouteOptions(routes) {
  const routeOptionsDiv = document.getElementById('route-options');
  routeOptionsDiv.innerHTML = '';
  previewLines.forEach(line => map.removeLayer(line));
  previewLines = [];

  const colors = ['orange', 'purple', 'hotpink'];
  routes.forEach((route, i) => {
    const coords = route.map(node => [nodeCoords[node][1], nodeCoords[node][0]]);
    const dist = route.reduce((sum, node, j) => {
      if (j < route.length - 1) {
        return sum + turf.distance(turf.point(nodeCoords[node]), turf.point(nodeCoords[route[j + 1]]));
      }
      return sum;
    }, 0);

    const line = L.polyline(coords, { color: colors[i % colors.length], weight: 4, dashArray: '5,5' }).addTo(map);
    previewLines.push(line);

    const div = document.createElement('div');
    div.className = 'route-option';
    div.textContent = `Route ${i + 1}: ${dist.toFixed(2)} km`;
    div.onclick = () => {
      previewLines.forEach(l => map.removeLayer(l));
      renderRoute(route);
      renderDirections(route);
    };
    routeOptionsDiv.appendChild(div);
  });
}

function renderRoute(path) {
  const coords = path.map(node => [nodeCoords[node][1], nodeCoords[node][0]]);
  if (routeLine) map.removeLayer(routeLine);
  routeLine = L.polyline(coords, { color: 'green', weight: 5 }).addTo(map);
}

function renderDirections(path) {
  const list = document.getElementById('directions');
  list.innerHTML = '';
  const instructions = generateDirections(path);

  instructions.forEach(text => {
    const li = document.createElement('li');
    li.textContent = text;
    list.appendChild(li);
  });

  const total = path.reduce((sum, node, i) => {
    if (i < path.length - 1) {
      return sum + turf.distance(turf.point(nodeCoords[node]), turf.point(nodeCoords[path[i + 1]]));
    }
    return sum;
  }, 0);

  document.getElementById('distance').textContent = total.toFixed(2);
  document.getElementById('time').textContent = Math.round(total * 12); // assume 5 km/h
}

// ðŸš€ Improved user-friendly direction generation
function generateDirections(path) {
  const instructions = [];
  for (let i = 1; i < path.length - 1; i++) {
    const prevCoord = nodeCoords[path[i - 1]];
    const currCoord = nodeCoords[path[i]];
    const nextCoord = nodeCoords[path[i + 1]];

    const prev = turf.point(prevCoord);
    const curr = turf.point(currCoord);
    const next = turf.point(nextCoord);

    const angle1 = turf.bearing(prev, curr);
    const angle2 = turf.bearing(curr, next);
    let angle = Math.abs(angle2 - angle1);
    if (angle > 180) angle = 360 - angle;

    if (angle > 30) {
      const turn = angle2 > angle1 ? "right" : "left";
      const segmentDistance = turf.distance(curr, next, { units: 'kilometers' });
      const roundedDistance = (segmentDistance * 1000).toFixed(0);

      instructions.push(`In ${roundedDistance} meters, turn ${turn}`);
    }
  }
  return instructions;
}
</script>
</body>
</html>
