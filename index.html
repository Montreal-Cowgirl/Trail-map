<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interactive Trail Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 80vh; width: 100vw; }
    #info { padding: 1rem; background: #f5f5f5; }
  </style>
</head>
<body>
<div id="map"></div>
<div id="info">
  <label for="routeSelect"><strong>Select Route Option:</strong></label>
  <select id="routeSelect"></select><br /><br />
  <strong>Distance:</strong> <span id="distance">-</span> km <br />
  <strong>Estimated Time:</strong> <span id="time">-</span> min <br />
  <strong>Directions:</strong>
  <ol id="directions"></ol>
</div>
<script>
let map = L.map('map', { doubleClickZoom: false }).setView([45.6362, -74.0345], 15);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

let trailData, graph = {}, nodeCoords = {}, nodeId = 0;
let startMarker, endMarker, routeLine = [], allPaths = [];
let clickCount = 0, startNode = null, endNode = null;

function coordKey(coord) {
  return `${coord[0].toFixed(5)},${coord[1].toFixed(5)}`;
}

function addEdge(a, b, dist) {
  if (!graph[a]) graph[a] = [];
  graph[a].push({ node: b, dist });
}

function buildGraph(data) {
  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        const a = coordKey(coords[i]);
        const b = coordKey(coords[i + 1]);
        const dist = turf.distance(turf.point(coords[i]), turf.point(coords[i + 1]));
        addEdge(a, b, dist);
        addEdge(b, a, dist);
        nodeCoords[a] = coords[i];
        nodeCoords[b] = coords[i + 1];
      }
    }
  });
}

function connectNearbyNodes(threshold = 0.001) {  // Reduced threshold for snapping nearby nodes
  const keys = Object.keys(nodeCoords);
  for (let i = 0; i < keys.length; i++) {
    for (let j = i + 1; j < keys.length; j++) {
      const a = keys[i];
      const b = keys[j];
      const d = turf.distance(turf.point(nodeCoords[a]), turf.point(nodeCoords[b]));
      if (d < threshold) {
        // Snapping nodes together by adding both to each other's connections
        addEdge(a, b, d);
        addEdge(b, a, d);
      }
    }
  }
}

function findClosestNode(latlng) {
  const pt = turf.point([latlng.lng, latlng.lat]);
  let closest = null, minDist = Infinity;
  Object.entries(nodeCoords).forEach(([key, coord]) => {
    const d = turf.distance(pt, turf.point(coord));
    if (d < minDist) {
      minDist = d;
      closest = key;
    }
  });
  return closest;
}

// Dijkstra's Algorithm (same as before)
function dijkstra(start, end, avoid = new Set()) {
  let dist = {}, prev = {}, visited = new Set();
  const queue = new MinHeap();
  Object.keys(graph).forEach(n => dist[n] = Infinity);
  dist[start] = 0;
  queue.push({ node: start, dist: 0 });

  while (queue.size() > 0) {
    const u = queue.pop().node;
    if (visited.has(u)) continue;
    visited.add(u);

    if (u === end) break;

    graph[u].forEach(({ node: v, dist: d }) => {
      if (visited.has(v) || avoid.has(v)) return;
      const alt = dist[u] + d;
      if (alt < dist[v]) {
        dist[v] = alt;
        prev[v] = u;
        queue.push({ node: v, dist: alt });
      }
    });
  }

  let path = [], u = end;
  while (prev[u]) {
    path.unshift(nodeCoords[u]);
    u = prev[u];
  }
  if (u === start) path.unshift(nodeCoords[u]);
  return path;
}

function showDirections(path) {
  let totalDist = 0;
  const ol = document.getElementById("directions");
  ol.innerHTML = "";

  for (let i = 0; i < path.length - 1; i++) {
    const from = turf.point(path[i]);
    const to = turf.point(path[i + 1]);
    const dist = turf.distance(from, to);
    totalDist += dist;

    const bearing = turf.bearing(from, to);
    const textDir = bearingToText(bearing);
    const cardinalDir = bearingToCardinal(bearing);

    const li = document.createElement("li");
    li.textContent = `${textDir} (${cardinalDir}) for ${dist.toFixed(2)} km`;
    ol.appendChild(li);
  }

  document.getElementById("distance").textContent = totalDist.toFixed(2);
  document.getElementById("time").textContent = Math.round((totalDist / 5) * 60);
}

function bearingToText(b) {
  if (b < 0) b += 360;
  if (b >= 337.5 || b < 22.5) return "Go straight ahead";
  if (b < 67.5) return "Turn slight right";
  if (b < 112.5) return "Turn right";
  if (b < 157.5) return "Turn sharp right";
  if (b < 202.5) return "Turn back";
  if (b < 247.5) return "Turn sharp left";
  if (b < 292.5) return "Turn left";
  return "Turn slight left";
}

function bearingToCardinal(b) {
  if (b < 0) b += 360;
  const dirs = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"];
  return dirs[Math.round(b / 45) % 8];
}

function findAlternativeRoutes(start, end, count = 3) {
  const mainPath = dijkstra(start, end);
  const routes = [mainPath];
  const avoidSet = new Set(mainPath.map(coord => coordKey(coord)));

  for (let i = 0; i < count - 1; i++) {
    const altPath = dijkstra(start, end, avoidSet);
    if (altPath.length > 0) {
      altPath.forEach(c => avoidSet.add(coordKey(c)));
      routes.push(altPath);
    } else break;
  }
  return routes;
}

function renderRoutes(paths) {
  routeLine.forEach(line => map.removeLayer(line));
  routeLine = [];
  const colors = ['green', 'orange', 'purple'];
  const select = document.getElementById("routeSelect");
  select.innerHTML = "";

  paths.forEach((path, idx) => {
    const line = L.polyline(path.map(c => [c[1], c[0]]), { color: colors[idx] }).addTo(map);
    routeLine.push(line);
    const option = document.createElement("option");
    option.value = idx;
    option.textContent = `Route ${idx + 1} (${colors[idx]})`;
    select.appendChild(option);
  });
  select.onchange = () => showDirections(paths[select.value]);
  select.value = 0;
  showDirections(paths[0]);
}

fetch('map.geojson')
  .then(res => res.json())
  .then(data => {
    trailData = data;
    L.geoJSON(data, { color: 'blue' }).addTo(map);
    buildGraph(data);
    connectNearbyNodes();  // Snapping nodes together with a smaller threshold
    console.log("âœ… Trails loaded and graph built.");
  });

map.on('click', function (e) {
  const
