<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interactive Trail Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 80vh; width: 100vw; }
    #info { padding: 1rem; background: #f5f5f5; }
  </style>
</head>
<body>
<div id="map"></div>
<div id="info">
  <label for="routeSelect"><strong>Select Route Option:</strong></label>
  <select id="routeSelect"></select><br /><br />
  <strong>Distance:</strong> <span id="distance">-</span> km <br />
  <strong>Estimated Time:</strong> <span id="time">-</span> min <br />
  <strong>Directions:</strong>
  <ol id="directions"></ol>
</div>

<script>
// Initialize map
let map = L.map('map', { doubleClickZoom: false }).setView([45.6362, -74.0345], 15);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

let trailData, graph = {}, nodeCoords = {}, nodeId = 0;
let startMarker, endMarker, routeLine = [], allPaths = [];
let clickCount = 0, startNode = null, endNode = null;
let userMarker;

// Function to display the user's location
function showUserLocation(position) {
  const lat = position.coords.latitude;
  const lng = position.coords.longitude;

  if (userMarker) {
    // Update the user's marker position if it's already on the map
    userMarker.setLatLng([lat, lng]);
  } else {
    // Create a new marker for the user's location
    userMarker = L.marker([lat, lng], { icon: L.icon({ iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34] }) }).addTo(map);
    map.setView([lat, lng], 15); // Center the map on the user's location
  }
}

// Function to handle errors when retrieving location
function showError(error) {
  console.warn(`ERROR(${error.code}): ${error.message}`);
}

// Trigger geolocation request on map click
map.on('click', function () {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(showUserLocation, showError, {
      enableHighAccuracy: true,
      maximumAge: 10000,
      timeout: 5000
    });
  } else {
    alert("Geolocation is not supported by your browser.");
  }
});

// The rest of your map initialization code...
function coordKey(coord) {
  return `${coord[0].toFixed(5)},${coord[1].toFixed(5)}`;
}

function addEdge(a, b, dist) {
  if (!graph[a]) graph[a] = [];
  graph[a].push({ node: b, dist });
}

function buildGraph(data) {
  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        const a = coordKey(coords[i]);
        const b = coordKey(coords[i + 1]);
        const dist = turf.distance(turf.point(coords[i]), turf.point(coords[i + 1]));
        addEdge(a, b, dist);
        addEdge(b, a, dist);
        nodeCoords[a] = coords[i];
        nodeCoords[b] = coords[i + 1];
      }
    }
  });
}

function connectNearbyNodes(threshold = 0.001) {
  const keys = Object.keys(nodeCoords);
  for (let i = 0; i < keys.length; i++) {
    for (let j = i + 1; j < keys.length; j++) {
      const a = keys[i];
      const b = keys[j];
      const d = turf.distance(turf.point(nodeCoords[a]), turf.point(nodeCoords[b]));
      if (d < threshold) {
        addEdge(a, b, d);
        addEdge(b, a, d);
      }
    }
  }
}

// Other functions related to pathfinding (like dijkstra, showDirections, etc.) remain the same...

fetch('map.geojson')
  .then(res => res.json())
  .then(data => {
    trailData = data;
    L.geoJSON(data, { color: 'blue' }).addTo(map);
    buildGraph(data);
    connectNearbyNodes();
    console.log("âœ… Trails loaded and graph built.");
  });

map.on('click', function (e) {
  const snapped = findClosestNode(e.latlng);
  if (!snapped) return alert("No nearby trail found.");
  const snappedLatLng = L.latLng(nodeCoords[snapped][1], nodeCoords[snapped][0]);

  if (clickCount === 0) {
    if (startMarker) map.removeLayer(startMarker);
    startMarker = L.marker(snappedLatLng).addTo(map);
    startNode = snapped;
    clickCount++;
  } else {
    if (endMarker) map.removeLayer(endMarker);
    endMarker = L.marker(snappedLatLng).addTo(map);
    endNode = snapped;
    clickCount = 0;

    const paths = findAlternativeRoutes(startNode, endNode, 3);
    if (!paths.length) return alert("No path found.");
    allPaths = paths;
    renderRoutes(paths);
  }
});

// Pathfinding functions
function findClosestNode(latlng) {
  let closestNode = null;
  let minDist = Infinity;
  Object.keys(nodeCoords).forEach(key => {
    const dist = turf.distance(turf.point([latlng.lng, latlng.lat]), turf.point(nodeCoords[key]));
    if (dist < minDist) {
      minDist = dist;
      closestNode = key;
    }
  });
  return closestNode;
}

function findAlternativeRoutes(start, end, numRoutes = 3) {
  // Simple route finding logic (to be expanded based on the graph structure)
  const routes = [];
  // Your pathfinding algorithm, such as Dijkstra's or A*, goes here.
  // The current example assumes that a single route is found, and will need further expansion.
  routes.push([start, end]); // Placeholder for actual pathfinding logic
  return routes;
}

function renderRoutes(paths) {
  // Clear previous routes
  if (routeLine.length) {
    routeLine.forEach(line => map.removeLayer(line));
    routeLine = [];
  }

  // Render the new paths
  paths.forEach((path, index) => {
    const coords = path.map(node => nodeCoords[node]);
    const line = L.polyline(coords, { color: index === 0 ? 'green' : 'red' }).addTo(map);
    routeLine.push(line);
  });
  updateRouteInfo(paths);
}

function updateRouteInfo(paths) {
  const routeSelect = document.getElementById('routeSelect');
  routeSelect.innerHTML = ''; // Clear previous options

  paths.forEach((path, index) => {
    const option = document.createElement('option');
    option.value = index;
    option.innerHTML = `Route ${index + 1}`;
    routeSelect.appendChild(option);
  });

  routeSelect.onchange = function () {
    const selectedRoute = paths[routeSelect.value];
    const coords = selectedRoute.map(node => nodeCoords[node]);
    const distance = turf.length(turf.lineString(coords));
    const time = Math.round(distance / 5 * 60); // Assuming 5 km/h walking speed

    document.getElementById('distance').innerText = distance.toFixed(2);
    document.getElementById('time').innerText = time;
    updateDirections(selectedRoute);
  };
}

function updateDirections(route) {
  const directionsList = document.getElementById('directions');
  directionsList.innerHTML = ''; // Clear previous directions
  // For simplicity, this just lists the nodes. You can implement a more sophisticated system based on segments.
  route.forEach((node, index) => {
    const li = document.createElement('li');
    li.innerHTML = `Turn at node: ${node}`;
    directionsList.appendChild(li);
  });
}
</script>
</body>
</html>
