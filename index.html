<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interactive Trail Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 80vh; width: 100vw; }
    #info { padding: 1rem; background: #f5f5f5; }
  </style>
</head>
<body>

<div id="map"></div>
<div id="info">
  <strong>Distance:</strong> <span id="distance">-</span> km <br />
  <strong>Estimated Time:</strong> <span id="time">-</span> min <br />
  <strong>Directions:</strong>
  <ol id="directions"></ol>
</div>

<script>
let map = L.map('map', { doubleClickZoom: false }).setView([45.6362, -74.0345], 15);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

let trailData, graph = {}, nodeCoords = {};
let startMarker, endMarker, clickCount = 0, startNode = null, endNode = null;
let userMarker, routeLines = [];

function showUserLocation(position) {
  const lat = position.coords.latitude;
  const lng = position.coords.longitude;
  if (userMarker) {
    userMarker.setLatLng([lat, lng]);
  } else {
    userMarker = L.marker([lat, lng]).addTo(map);
    map.setView([lat, lng], 15);
  }
}

function showError(error) {
  console.warn(`ERROR(${error.code}): ${error.message}`);
}

if (navigator.geolocation) {
  navigator.geolocation.watchPosition(showUserLocation, showError, {
    enableHighAccuracy: true,
    maximumAge: 10000,
    timeout: 5000
  });
} else {
  alert("Geolocation is not supported by your browser.");
}

function coordKey(coord) {
  return `${coord[1].toFixed(5)},${coord[0].toFixed(5)}`;
}

function addEdge(a, b, dist) {
  if (!graph[a]) graph[a] = [];
  graph[a].push({ node: b, dist });
}

function buildGraph(data) {
  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        const a = coordKey(coords[i]);
        const b = coordKey(coords[i + 1]);
        const dist = turf.distance(turf.point(coords[i]), turf.point(coords[i + 1]));
        addEdge(a, b, dist);
        addEdge(b, a, dist);
        nodeCoords[a] = coords[i];
        nodeCoords[b] = coords[i + 1];
      }
    }
  });
}

function connectNearbySegments(data, threshold = 25) {
  const lineSegments = [];
  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        lineSegments.push([coords[i], coords[i + 1]]);
      }
    }
  });

  for (let i = 0; i < lineSegments.length; i++) {
    for (let j = i + 1; j < lineSegments.length; j++) {
      const line1 = turf.lineString(lineSegments[i]);
      const line2 = turf.lineString(lineSegments[j]);

      const dist = turf.pointToLineDistance(
        turf.midpoint(line1.geometry.coordinates[0], line1.geometry.coordinates[1]),
        line2,
        { units: 'meters' }
      );

      if (dist <= threshold) {
        const pt1 = turf.nearestPointOnLine(line2, turf.midpoint(...line1.geometry.coordinates));
        const pt2 = turf.nearestPointOnLine(line1, turf.midpoint(...line2.geometry.coordinates));

        const a = coordKey(pt1.geometry.coordinates);
        const b = coordKey(pt2.geometry.coordinates);
        const distBetween = turf.distance(pt1, pt2);

        nodeCoords[a] = pt1.geometry.coordinates;
        nodeCoords[b] = pt2.geometry.coordinates;

        addEdge(a, b, distBetween);
        addEdge(b, a, distBetween);
      }
    }
  }
}

function findClosestNode(latLng) {
  let minDist = Infinity;
  let closestNode = null;
  const threshold = 100;
  Object.keys(nodeCoords).forEach(key => {
    const nodeLatLng = L.latLng(nodeCoords[key][1], nodeCoords[key][0]);
    const dist = latLng.distanceTo(nodeLatLng);
    if (dist < minDist && dist <= threshold) {
      minDist = dist;
      closestNode = key;
    }
  });
  return closestNode;
}

fetch('map.geojson')
  .then(res => res.json())
  .then(data => {
    trailData = data;
    L.geoJSON(data, { color: 'blue' }).addTo(map);
    buildGraph(data);
    connectNearbySegments(data);
  });

map.on('click', function (e) {
  const snapped = findClosestNode(e.latlng);
  if (!snapped) return alert("No nearby trail found.");
  const snappedLatLng = L.latLng(nodeCoords[snapped][1], nodeCoords[snapped][0]);

  const greenIcon = L.icon({
    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
  });

  const redIcon = L.icon({
    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
  });

  if (clickCount === 0) {
    if (startMarker) map.removeLayer(startMarker);
    startMarker = L.marker(snappedLatLng, { icon: greenIcon }).addTo(map);
    startNode = snapped;
    clickCount++;
  } else {
    if (endMarker) map.removeLayer(endMarker);
    endMarker = L.marker(snappedLatLng, { icon: redIcon }).addTo(map);
    endNode = snapped;
    clickCount = 0;

    console.log("Start node:", startNode);
    console.log("End node:", endNode);

    try {
      const path = dijkstra(startNode, endNode);
      if (!path || path.length === 0) return alert("No path found.");

      routeLines.forEach(line => map.removeLayer(line));
      routeLines = [];
      renderRoute(path, true);
      renderDirections(path);
    } catch (err) {
      console.error("Error finding route:", err);
      alert("There was an error finding the route. Check console for details.");
    }
  }
});

function dijkstra(start, end) {
  const distances = {}, prev = {}, visited = new Set(), pq = [];
  distances[start] = 0;
  pq.push({ node: start, dist: 0 });

  while (pq.length > 0) {
    pq.sort((a, b) => a.dist - b.dist);
    const { node: u } = pq.shift();
    if (visited.has(u)) continue;
    visited.add(u);

    if (u === end) break;

    for (const neighbor of graph[u] || []) {
      const alt = distances[u] + neighbor.dist;
      if (alt < (distances[neighbor.node] || Infinity)) {
        distances[neighbor.node] = alt;
        prev[neighbor.node] = u;
        pq.push({ node: neighbor.node, dist: alt });
      }
    }
  }

  const path = [];
  let curr = end;
  while (curr) {
    path.unshift(curr);
    curr = prev[curr];
  }
  return path[0] === start ? path : [];
}

function renderRoute(path, isPrimary = false) {
  const routeCoords = path.map(node => [nodeCoords[node][1], nodeCoords[node][0]]);
  const color = isPrimary ? 'green' : 'gray';
  const line = L.polyline(routeCoords, { color, weight: 5 }).addTo(map);
  routeLines.push(line);
}

function renderDirections(path) {
  const directionsList = document.getElementById('directions');
  directionsList.innerHTML = '';
  let totalDistance = 0;
  let prevBearing = null;

  for (let i = 0; i < path.length - 1; i++) {
    const from = turf.point(nodeCoords[path[i]]);
    const to = turf.point(nodeCoords[path[i + 1]]);
    const dist = turf.distance(from, to);
    totalDistance += dist;

    const bearing = turf.bearing(from, to);
    let instruction = '';

    if (prevBearing !== null) {
      let angle = bearing - prevBearing;
      if (angle > 180) angle -= 360;
      if (angle < -180) angle += 360;

      const absAngle = Math.abs(angle);
      if (absAngle > 30) {
        if (angle > 0) {
          instruction = `Turn right`;
        } else {
          instruction = `Turn left`;
        }
      } else {
        instruction = `Continue straight`;
      }
    } else {
      instruction = `Start on trail heading ${bearing.toFixed(0)}Â°`;
    }

    prevBearing = bearing;

    const coord = nodeCoords[path[i + 1]];
    const li = document.createElement('li');
    li.textContent = `${instruction} toward (${coord[1].toFixed(5)}, ${coord[0].toFixed(5)})`;
    directionsList.appendChild(li);
  }

  document.getElementById('distance').textContent = totalDistance.toFixed(2);
  document.getElementById('time').textContent = Math.round(totalDistance * 12);
}
</script>

</body>
</html>
