<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interactive Trail Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 80vh; width: 100vw; }
    #info { padding: 1rem; background: #f5f5f5; }
    #route-options { margin-top: 1rem; }
    .route-option {
      margin: 4px 0;
      cursor: pointer;
      padding: 4px 8px;
      background: #e0e0e0;
      border-radius: 4px;
    }
    .route-option:hover {
      background: #d0d0d0;
    }
    #season-select {
      margin: 1rem 0;
    }
  </style>
</head>
<body>

<div id="map"></div>
<div id="info">
  <label for="season-select"><strong>Trail Filter:</strong></label>
  <select id="season-select">
    <option value="auto">Auto (Based on Date)</option>
    <option value="summer">Summer Mode</option>
    <option value="winter">Winter Mode</option>
    <option value="all">All Trails</option>
  </select><br/>
  <strong>Distance:</strong> <span id="distance">-</span> km <br />
  <strong>Estimated Time:</strong> <span id="time">-</span> min <br />
  <strong>Directions:</strong>
  <ol id="directions"></ol>
  <div id="route-options"></div>
</div>

<script>
let graph = {}, nodeCoords = {}, geojsonData;
const map = L.map('map').setView([46.8, -71.2], 13);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

let startMarker = null;
let endMarker = null;
let userLocation = null;
let routeLayers = [];

function addEdge(a, b, dist) {
  if (!graph[a]) graph[a] = [];
  graph[a].push({ node: b, dist });
}

function coordKey(coord) {
  return coord[0].toFixed(5) + "," + coord[1].toFixed(5);
}

function getAllowedSeasonKeywords(mode = "auto") {
  if (mode === "all") return null;
  const keywords = ["saison"];
  if (mode === "summer") {
    keywords.push("été");
  } else if (mode === "winter") {
    keywords.push("hiver");
  } else {
    const now = new Date();
    const month = now.getMonth();
    const date = now.getDate();
    const isWinter = (month === 11 && date >= 21) || (month <= 2) || (month === 3 && date <= 30);
    keywords.push(isWinter ? "hiver" : "été");
  }
  return keywords;
}

function normalize(str) {
  return str.normalize("NFD").replace(/\p{Diacritic}/gu, "").toLowerCase();
}

function hasSeasonKeyword(name, allowedKeywords) {
  if (!allowedKeywords) return true;
  const normName = normalize(name || "");
  return allowedKeywords.some(kw => normName.includes(normalize(kw)));
}

function buildGraph(data, seasonMode) {
  console.log("Building graph for season mode:", seasonMode);
  graph = {}; nodeCoords = {};
  const allowedKeywords = getAllowedSeasonKeywords(seasonMode);
  let skipped = 0, added = 0;

  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const name = f.properties.name || f.properties.NOM || "";
      if (!hasSeasonKeyword(name, allowedKeywords)) {
        skipped++;
        return;
      }

      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        const a = coordKey(coords[i]);
        const b = coordKey(coords[i + 1]);
        const dist = turf.distance(turf.point(coords[i]), turf.point(coords[i + 1]));
        addEdge(a, b, dist);
        addEdge(b, a, dist);
        nodeCoords[a] = coords[i];
        nodeCoords[b] = coords[i + 1];
        added++;
      }
    }
  });
  console.log(`Graph built with ${added} connections and ${skipped} skipped features.`);
  renderGeoJson(data, allowedKeywords);
}

function renderGeoJson(data, allowedKeywords) {
  if (window.trailsLayer) map.removeLayer(window.trailsLayer);
  window.trailsLayer = L.geoJSON(data, {
    filter: f => {
      const name = f.properties.name || f.properties.NOM || "";
      return hasSeasonKeyword(name, allowedKeywords);
    },
    style: { color: 'blue', weight: 3 }
  }).addTo(map);
}

function generateDirections(path) {
  console.log("Generating directions for path of length:", path.length);
  const instructions = [];
  for (let i = 1; i < path.length - 1; i++) {
    const prevCoord = nodeCoords[path[i - 1]];
    const currCoord = nodeCoords[path[i]];
    const nextCoord = nodeCoords[path[i + 1]];

    const prev = turf.point(prevCoord);
    const curr = turf.point(currCoord);
    const next = turf.point(nextCoord);

    const angle1 = turf.bearing(prev, curr);
    const angle2 = turf.bearing(curr, next);
    let angle = Math.abs(angle2 - angle1);
    if (angle > 180) angle = 360 - angle;

    if (angle > 30) {
      const turn = angle2 > angle1 ? "right" : "left";
      const segmentDistance = turf.distance(curr, next, { units: 'kilometers' });
      const roundedDistance = (segmentDistance * 1000).toFixed(0);
      instructions.push(`In ${roundedDistance} meters, turn ${turn}`);
    }
  }
  const dirList = document.getElementById("directions");
  dirList.innerHTML = "";
  instructions.forEach(txt => {
    const li = document.createElement("li");
    li.textContent = txt;
    dirList.appendChild(li);
  });
  return instructions;
}

function findNearestNode(latlng) {
  let nearest = null, minDist = Infinity;
  for (let key in nodeCoords) {
    const coord = nodeCoords[key];
    const dist = turf.distance(turf.point([latlng.lng, latlng.lat]), turf.point(coord));
    if (dist < minDist) {
      minDist = dist;
      nearest = key;
    }
  }
  console.log("Nearest node to", latlng, "is", nearest, "at distance", minDist);
  return nearest;
}


function addTemporaryNodeToGraph(snappedPoint) {
  const tempKey = coordKey([snappedPoint.lng, snappedPoint.lat]);
  let closestSegment = null;
  let minDist = Infinity;

  // Find the closest segment in the GeoJSON trail data
  geojsonData.features.forEach(f => {
    if (f.geometry.type === "LineString") {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        const a = coords[i];
        const b = coords[i + 1];
        const line = turf.lineString([a, b]);
        const dist = turf.pointToLineDistance(turf.point([snappedPoint.lng, snappedPoint.lat]), line);
        if (dist < minDist) {
          minDist = dist;
          closestSegment = { a, b };
        }
      }
    }
  });

  if (closestSegment) {
    const { a, b } = closestSegment;
    const distToA = turf.distance(turf.point(a), turf.point([snappedPoint.lng, snappedPoint.lat]));
    const distToB = turf.distance(turf.point(b), turf.point([snappedPoint.lng, snappedPoint.lat]));

    // Add temporary edges from snapped point to a and b
    const aKey = coordKey(a);
    const bKey = coordKey(b);

    graph[tempKey] = [];
    graph[tempKey].push({ node: aKey, dist: distToA });
    graph[tempKey].push({ node: bKey, dist: distToB });

    // Also add edges in the reverse direction so Dijkstra can reach it
    if (!graph[aKey]) graph[aKey] = [];
    if (!graph[bKey]) graph[bKey] = [];

    graph[aKey].push({ node: tempKey, dist: distToA });
    graph[bKey].push({ node: tempKey, dist: distToB });

    nodeCoords[tempKey] = [snappedPoint.lng, snappedPoint.lat];
  }

  return tempKey;
}


  function addSnappedPointToGraph(latlng) {
  const pt = turf.point([latlng.lng, latlng.lat]);
  let minDist = Infinity;
  let snappedCoord = null;
  let segmentEnds = [];

  geojsonData.features.forEach(f => {
    if (f.geometry.type === "LineString") {
      const line = turf.lineString(f.geometry.coordinates);
      const snapped = turf.nearestPointOnLine(line, pt);
      if (snapped.properties.dist < minDist) {
        minDist = snapped.properties.dist;
        snappedCoord = snapped.geometry.coordinates;

        const segIndex = snapped.properties.index;
        const coords = f.geometry.coordinates;

        if (segIndex < coords.length - 1) {
          segmentEnds = [coords[segIndex], coords[segIndex + 1]];
        }
      }
    }
  });

  if (!snappedCoord || segmentEnds.length !== 2) {
    console.warn("Snapping failed.");
    return null;
  }

  const keySnapped = coordKey(snappedCoord);
  nodeCoords[keySnapped] = snappedCoord;

  const [a, b] = segmentEnds;
  const keyA = coordKey(a);
  const keyB = coordKey(b);

  // Add bidirectional edges to the graph
  const distA = turf.distance(turf.point(a), turf.point(snappedCoord));
  const distB = turf.distance(turf.point(b), turf.point(snappedCoord));
  addEdge(keyA, keySnapped, distA);
  addEdge(keySnapped, keyA, distA);
  addEdge(keyB, keySnapped, distB);
  addEdge(keySnapped, keyB, distB);

  return keySnapped;
}

  function injectPointIntoGraph(latlng, graph, nodeCoords) {
  const point = turf.point([latlng.lng, latlng.lat]);

  let minDist = Infinity;
  let closestSegment = null;
  let snappedCoord = null;

  geojson.features.forEach(feature => {
    if (feature.geometry.type === "LineString") {
      const line = turf.lineString(feature.geometry.coordinates);
      const snapped = turf.nearestPointOnLine(line, point);
      const dist = snapped.properties.dist;
      if (dist < minDist) {
        minDist = dist;
        closestSegment = line;
        snappedCoord = snapped.geometry.coordinates;
      }
    }
  });

  if (!closestSegment || !snappedCoord) return null;

  const coords = closestSegment.geometry.coordinates;
  let insertIndex = -1;
  let minSegDist = Infinity;

  for (let i = 0; i < coords.length - 1; i++) {
    const seg = turf.lineString([coords[i], coords[i + 1]]);
    const proj = turf.nearestPointOnLine(seg, point);
    const d = proj.properties.dist;
    if (d < minSegDist) {
      minSegDist = d;
      insertIndex = i;
    }
  }

  if (insertIndex === -1) return null;

  const key = `${snappedCoord[0].toFixed(5)},${snappedCoord[1].toFixed(5)}`;
  if (nodeCoords[key]) return key; // already in graph

  const from = coords[insertIndex];
  const to = coords[insertIndex + 1];
  const distFrom = turf.distance(turf.point(from), turf.point(snappedCoord));
  const distTo = turf.distance(turf.point(to), turf.point(snappedCoord));

  const fromKey = `${from[0].toFixed(5)},${from[1].toFixed(5)}`;
  const toKey = `${to[0].toFixed(5)},${to[1].toFixed(5)}`;

  graph[key] = {};
  if (graph[fromKey]) {
    graph[key][fromKey] = distFrom;
    graph[fromKey][key] = distFrom;
  }
  if (graph[toKey]) {
    graph[key][toKey] = distTo;
    graph[toKey][key] = distTo;
  }

  nodeCoords[key] = [snappedCoord[0], snappedCoord[1]];
  return key;
}

  
function dijkstra(startKey, endKey) {
  console.log("Running Dijkstra from", startKey, "to", endKey);
  const dist = {}, prev = {}, visited = new Set();
  dist[startKey] = 0;

  let iterations = 0, maxIterations = 20000;
  const queue = new Set([startKey]);

  while (queue.size > 0 && iterations++ < maxIterations) {
    let u = null;
    let minDist = Infinity;

    for (let node of queue) {
      if (dist[node] < minDist) {
        minDist = dist[node];
        u = node;
      }
    }

    if (!u) break;
    queue.delete(u);

    if (iterations % 1000 === 0) {
      console.log(`Iteration ${iterations}, visiting ${u}, dist=${dist[u]}`);
    }

    if (u === endKey) break;

    visited.add(u);
    for (let neighbor of (graph[u] || [])) {
      if (visited.has(neighbor.node)) continue;
      const alt = dist[u] + neighbor.dist;
      if (alt < (dist[neighbor.node] || Infinity)) {
        dist[neighbor.node] = alt;
        prev[neighbor.node] = u;
        queue.add(neighbor.node);
      }
    }
  }

  if (iterations >= maxIterations) {
    console.warn("❌ Dijkstra aborted: too many iterations or disconnected graph.");
    alert("⚠️ Route search failed: too many steps. This might be due to disconnected trails.");
    return [];
  }

  const path = [];
  let u = endKey;
  while (u) {
    path.unshift(u);
    u = prev[u];
  }

  if (path[0] !== startKey) {
    console.warn("❌ No path could be reconstructed from", startKey, "to", endKey);
    alert("⚠️ Unable to reconstruct route. Trails might be disconnected.");
    return [];
  }

  console.log("✅ Dijkstra finished. Path length:", path.length);
  return path;
}


function drawRoute(path) {
  console.log("Drawing route with", path.length, "points.");
  routeLayers.forEach(l => map.removeLayer(l));
  routeLayers = [];

const coords = path.map(k => {
  const coord = nodeCoords[k];
  // If it's a GeoJSON Point, extract coordinates
  if (coord && coord.type === "Point" && Array.isArray(coord.coordinates)) {
    return [coord.coordinates[1], coord.coordinates[0]]; // [lat, lng]
  }
  // If it's a flat [lng, lat] or [lat, lng]
  if (Array.isArray(coord) && coord.length === 2 && typeof coord[0] === "number") {
    return coord;
  }
  // If it's something else (like [lng, lat, elevation]), trim it
  if (Array.isArray(coord) && coord.length >= 2) {
    return [coord[1], coord[0]]; // Assume [lng, lat, ...] → convert to [lat, lng]
  }
  console.warn("Invalid coordinate:", coord);
  return null;
}).filter(Boolean);

  console.log("Route coordinates:", coords);
  if (coords.length < 2) {
    console.warn("Not enough valid coordinates to draw route.");
    return;
  }


  const line = L.polyline(coords, { color: 'orange', weight: 4 }).addTo(map);
  routeLayers.push(line);

  const totalDist = coords.reduce((sum, _, i) => {
    if (i === 0) return 0;
    return sum + turf.distance(turf.point(coords[i - 1]), turf.point(coords[i]));
  }, 0);

  document.getElementById("distance").textContent = totalDist.toFixed(2);
  document.getElementById("time").textContent = Math.round((totalDist / 5) * 60);
}




map.on("click", e => {
  console.log("Map clicked at", e.latlng);

  const clickPoint = turf.point([e.latlng.lng, e.latlng.lat]);
  const allowedKeywords = getAllowedSeasonKeywords(document.getElementById('season-select').value);

  let minDist = Infinity;
  let snappedPoint = null;

  geojsonData.features.forEach(f => {
    const name = f.properties.name || f.properties.NOM || "";
    if (!hasSeasonKeyword(name, allowedKeywords)) return;

    if (f.geometry.type === 'LineString') {
      const line = turf.lineString(f.geometry.coordinates);
      const candidate = turf.nearestPointOnLine(line, clickPoint, { units: 'kilometers' });
      const dist = turf.pointToLineDistance(clickPoint, line, { units: 'kilometers' });

      if (dist < minDist) {
        minDist = dist;
        snappedPoint = candidate;
      }
    }
  });

  if (!snappedPoint) {
    alert("❌ No nearby trail segment found.");
    return;
  }

  const snappedLatLng = L.latLng(snappedPoint.geometry.coordinates[1], snappedPoint.geometry.coordinates[0]);

  if (!startMarker) {
    startMarker = L.marker(snappedLatLng, {
      draggable: true,
      icon: L.icon({
        iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/green-dot.png',
        iconSize: [32, 32],
        iconAnchor: [16, 32]
      })
    }).addTo(map);
  } else if (!endMarker) {
    endMarker = L.marker(snappedLatLng, {
      draggable: true,
      icon: L.icon({
        iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/red-dot.png',
        iconSize: [32, 32],
        iconAnchor: [16, 32]
      })
    }).addTo(map);

    const startKey = injectPointIntoGraph(startMarker.getLatLng(), graph, nodeCoords);
    const endKey = injectPointIntoGraph(endMarker.getLatLng(), graph, nodeCoords);
    
    // Snap the marker locations to the nearest point on a trail
const snappedStart = turf.nearestPointOnLine(trailsGeoJSON, startMarker.getLatLng());
const snappedEnd = turf.nearestPointOnLine(trailsGeoJSON, endMarker.getLatLng());

// Get the snapped coordinates as [lng, lat] keys
const snappedStartCoords = [snappedStart.geometry.coordinates[0], snappedStart.geometry.coordinates[1]];
const snappedEndCoords = [snappedEnd.geometry.coordinates[0], snappedEnd.geometry.coordinates[1]];

// Convert to keys for the graph
startKey = `${snappedStartCoords[0].toFixed(5)},${snappedStartCoords[1].toFixed(5)}`;
endKey = `${snappedEndCoords[0].toFixed(5)},${snappedEndCoords[1].toFixed(5)}`;

// Inject into graph if not already present
if (!graph[startKey]) {
  graph[startKey] = findNearestGraphConnections(snappedStartCoords);
  nodeCoords[startKey] = snappedStartCoords;
}
if (!graph[endKey]) {
  graph[endKey] = findNearestGraphConnections(snappedEndCoords);
  nodeCoords[endKey] = snappedEndCoords;
}

    
    const path = dijkstra(startKey, endKey);

    if (path.length > 0) {
      drawRoute(path);
    } else {
      alert("No path found.");
      console.warn("No path found between", startKey, "and", endKey);
    }
  } else {
    map.removeLayer(startMarker);
    map.removeLayer(endMarker);
    startMarker = null;
    endMarker = null;
    routeLayers.forEach(l => map.removeLayer(l));
    routeLayers = [];
    document.getElementById("distance").textContent = "-";
    document.getElementById("time").textContent = "-";
    document.getElementById("directions").innerHTML = "";
  }
});




navigator.geolocation.getCurrentPosition(pos => {
  userLocation = [pos.coords.latitude, pos.coords.longitude];
  L.marker(userLocation).addTo(map).bindPopup("You are here").openPopup();
  map.setView(userLocation, 14);
});

fetch('map.geojson')
  .then(res => res.json())
  .then(data => {
    geojsonData = data;
    const dropdown = document.getElementById('season-select');
    dropdown.addEventListener('change', () => {
      console.log("Season dropdown changed to:", dropdown.value);
      buildGraph(geojsonData, dropdown.value);
    });
    buildGraph(data, dropdown.value);
  })
  .catch(err => console.error("Failed to load map data:", err));
</script>

</body>
</html>
