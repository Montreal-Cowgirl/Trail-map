<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Trail Map with Routing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    #map { height: 600px; }
    body { font-family: Arial, sans-serif; }
  </style>
</head>
<body>
  <h2>Trail Map</h2>
  <div id="map"></div>
  <p><strong>Distance:</strong> <span id="distance"></span> km</p>
  <p><strong>Estimated Time:</strong> <span id="time"></span> min</p>
  <p><strong>Directions:</strong></p>
  <ol id="directions"></ol>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
    const map = L.map('map').setView([45.594, -73.930], 16);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Map data Â© OpenStreetMap contributors'
    }).addTo(map);

    const startIcon = L.icon({
      iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
      iconAnchor: [12, 41],
      popupAnchor: [0, -41],
    });

    const endIcon = L.icon({
      iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-red.png',
      iconAnchor: [12, 41],
      popupAnchor: [0, -41],
    });

    let nodeCoords = {};
    let edgeGeometries = {};
    let trailLayer;

    fetch('map.geojson')
      .then(res => res.json())
      .then(data => {
        trailLayer = L.geoJSON(data, {
          style: { color: 'blue' },
          onEachFeature: (feature) => {
            const coords = feature.geometry.coordinates;
            const start = coords[0].join(',');
            const end = coords[coords.length - 1].join(',');
            edgeGeometries[`${start}|${end}`] = coords;
            edgeGeometries[`${end}|${start}`] = [...coords].reverse();

            // Store nodes for routing use
            coords.forEach(coord => {
              const key = coord.join(',');
              if (!nodeCoords[key]) {
                nodeCoords[key] = coord;
              }
            });
          }
        }).addTo(map);

        // Build graph from edges for Dijkstra
        buildGraphAndRunRouting();
      });

    let graph = {};

    function buildGraphAndRunRouting() {
      for (const edgeKey in edgeGeometries) {
        const [fromKey, toKey] = edgeKey.split('|');
        if (!graph[fromKey]) graph[fromKey] = [];
        const distance = turf.length(turf.lineString(edgeGeometries[edgeKey]));
        graph[fromKey].push({ node: toKey, distance });
      }

      const start = Object.keys(graph)[0];
      const end = Object.keys(graph).slice(-1)[0];
      const path = dijkstra(start, end);
      renderRoute(path);
      renderDirections(path);
    }

    function dijkstra(start, end) {
      const distances = {};
      const prev = {};
      const visited = new Set();
      const queue = new Set(Object.keys(graph));

      for (const node of queue) {
        distances[node] = Infinity;
      }
      distances[start] = 0;

      while (queue.size > 0) {
        const current = [...queue].reduce((a, b) => distances[a] < distances[b] ? a : b);
        queue.delete(current);
        visited.add(current);

        if (current === end) break;

        for (const neighbor of graph[current] || []) {
          const alt = distances[current] + neighbor.distance;
          if (alt < distances[neighbor.node]) {
            distances[neighbor.node] = alt;
            prev[neighbor.node] = current;
          }
        }
      }

      const path = [];
      let curr = end;
      while (curr) {
        path.unshift(curr);
        curr = prev[curr];
      }
      return path;
    }

    function renderRoute(path) {
      let fullCoords = [];
      for (let i = 0; i < path.length - 1; i++) {
        const seg = edgeGeometries[`${path[i]}|${path[i + 1]}`];
        if (seg) fullCoords.push(...seg);
      }
      const latLngs = fullCoords.map(coord => [coord[1], coord[0]]);
      L.polyline(latLngs, { color: 'green', weight: 4 }).addTo(map);

      L.marker([nodeCoords[path[0]][1], nodeCoords[path[0]][0]], { icon: startIcon }).addTo(map);
      L.marker([nodeCoords[path[path.length - 1]][1], nodeCoords[path[path.length - 1]][0]], { icon: endIcon }).addTo(map);
    }

    function renderDirections(path) {
      const directionsList = document.getElementById('directions');
      directionsList.innerHTML = '';
      let totalDistance = 0;
      let prevBearing = null;
      let prevPoint = nodeCoords[path[0]];
      let accumulated = 0;

      for (let i = 0; i < path.length - 1; i++) {
        const from = nodeCoords[path[i]];
        const to = nodeCoords[path[i + 1]];
        const dist = turf.distance(turf.point(from), turf.point(to));
        totalDistance += dist;

        const bearing = turf.bearing(turf.point(from), turf.point(to));
        if (prevBearing !== null) {
          let delta = bearing - prevBearing;
          if (delta > 180) delta -= 360;
          if (delta < -180) delta += 360;

          const absDelta = Math.abs(delta);
          if (absDelta >= 25) {
            let dir = '';
            if (absDelta < 45) dir = delta > 0 ? 'Slight right' : 'Slight left';
            else if (absDelta < 135) dir = delta > 0 ? 'Turn right' : 'Turn left';
            else dir = 'Make a U-turn';

            const li = document.createElement('li');
            li.textContent = `${dir} in ${Math.round(accumulated * 1000)}m`;
            directionsList.appendChild(li);
            accumulated = 0;
          }
        }

        accumulated += dist;
        prevBearing = bearing;
        prevPoint = to;
      }

      document.getElementById('distance').textContent = totalDistance.toFixed(2);
      document.getElementById('time').textContent = Math.round(totalDistance * 12); // 5 km/h
    }
  </script>
</body>
</html>
