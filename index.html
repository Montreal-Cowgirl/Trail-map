<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interactive Trail Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 80vh; width: 100vw; }
    #info { padding: 1rem; background: #f5f5f5; }
    #route-options { margin-top: 1rem; }
    .route-option {
      margin: 4px 0;
      cursor: pointer;
      padding: 4px 8px;
      background: #e0e0e0;
      border-radius: 4px;
    }
    .route-option:hover {
      background: #d0d0d0;
    }
    #season-select {
      margin: 1rem 0;
    }
  </style>
</head>
<body>

<div id="map"></div>
<div id="info">
  <label for="season-select"><strong>Trail Filter:</strong></label>
  <select id="season-select">
    <option value="auto">Auto (Based on Date)</option>
    <option value="summer">Summer Mode</option>
    <option value="winter">Winter Mode</option>
    <option value="all">All Trails</option>
  </select><br/>
  <strong>Distance:</strong> <span id="distance">-</span> km <br />
  <strong>Estimated Time:</strong> <span id="time">-</span> min <br />
  <strong>Directions:</strong>
  <ol id="directions"></ol>
  <div id="route-options"></div>
</div>

<script>
let graph = {}, nodeCoords = {}, geojsonData;
const map = L.map('map').setView([46.8, -71.2], 13);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

let startMarker = null;
let endMarker = null;
let userLocation = null;
let routeLayers = [];

function addEdge(a, b, dist) {
  if (!graph[a]) graph[a] = [];
  graph[a].push({ node: b, dist });
}

function coordKey(coord) {
  return coord[0].toFixed(5) + "," + coord[1].toFixed(5);
}

function getAllowedSeasonKeywords(mode = "auto") {
  if (mode === "all") return null;
  const keywords = ["saison"];
  if (mode === "summer") {
    keywords.push("été");
  } else if (mode === "winter") {
    keywords.push("hiver");
  } else {
    const now = new Date();
    const month = now.getMonth();
    const date = now.getDate();
    const isWinter = (month === 11 && date >= 21) || (month <= 2) || (month === 3 && date <= 30);
    keywords.push(isWinter ? "hiver" : "été");
  }
  return keywords;
}

function normalize(str) {
  return str.normalize("NFD").replace(/\p{Diacritic}/gu, "").toLowerCase();
}

function hasSeasonKeyword(name, allowedKeywords) {
  if (!allowedKeywords) return true;
  const normName = normalize(name || "");
  return allowedKeywords.some(kw => normName.includes(normalize(kw)));
}

function buildGraph(data, seasonMode) {
  console.log("Building graph for season mode:", seasonMode);
  graph = {}; nodeCoords = {};
  const allowedKeywords = getAllowedSeasonKeywords(seasonMode);
  let skipped = 0, added = 0;

  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const name = f.properties.name || f.properties.NOM || "";
      if (!hasSeasonKeyword(name, allowedKeywords)) {
        skipped++;
        return;
      }

      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        const a = coordKey(coords[i]);
        const b = coordKey(coords[i + 1]);
        const dist = turf.distance(turf.point(coords[i]), turf.point(coords[i + 1]));
        addEdge(a, b, dist);
        addEdge(b, a, dist);
        nodeCoords[a] = coords[i];
        nodeCoords[b] = coords[i + 1];
        added++;
      }
    }
  });
  console.log(`Graph built with ${added} connections and ${skipped} skipped features.`);
  renderGeoJson(data, allowedKeywords);
}

function renderGeoJson(data, allowedKeywords) {
  if (window.trailsLayer) map.removeLayer(window.trailsLayer);
  window.trailsLayer = L.geoJSON(data, {
    filter: f => {
      const name = f.properties.name || f.properties.NOM || "";
      return hasSeasonKeyword(name, allowedKeywords);
    },
    style: { color: 'blue', weight: 3 }
  }).addTo(map);
}

function generateDirections(path) {
  console.log("Generating directions for path of length:", path.length);
  const instructions = [];
  for (let i = 1; i < path.length - 1; i++) {
    const prevCoord = nodeCoords[path[i - 1]];
    const currCoord = nodeCoords[path[i]];
    const nextCoord = nodeCoords[path[i + 1]];

    const prev = turf.point(prevCoord);
    const curr = turf.point(currCoord);
    const next = turf.point(nextCoord);

    const angle1 = turf.bearing(prev, curr);
    const angle2 = turf.bearing(curr, next);
    let angle = Math.abs(angle2 - angle1);
    if (angle > 180) angle = 360 - angle;

    if (angle > 30) {
      const turn = angle2 > angle1 ? "right" : "left";
      const segmentDistance = turf.distance(curr, next, { units: 'kilometers' });
      const roundedDistance = (segmentDistance * 1000).toFixed(0);
      instructions.push(`In ${roundedDistance} meters, turn ${turn}`);
    }
  }
  const dirList = document.getElementById("directions");
  dirList.innerHTML = "";
  instructions.forEach(txt => {
    const li = document.createElement("li");
    li.textContent = txt;
    dirList.appendChild(li);
  });
  return instructions;
}

function findNearestNode(latlng) {
  let nearest = null, minDist = Infinity;
  for (let key in nodeCoords) {
    const coord = nodeCoords[key];
    const dist = turf.distance(turf.point([latlng.lng, latlng.lat]), turf.point(coord));
    if (dist < minDist) {
      minDist = dist;
      nearest = key;
    }
  }
  console.log("Nearest node to", latlng, "is", nearest, "at distance", minDist);
  return nearest;
}

function dijkstra(startKey, endKey) {
  console.log("Running Dijkstra from", startKey, "to", endKey);
  const dist = {}, prev = {}, visited = new Set();
  dist[startKey] = 0;

  let iterations = 0, maxIterations = 20000;
  const queue = new Set([startKey]);

  while (queue.size > 0 && iterations++ < maxIterations) {
    let u = null;
    let minDist = Infinity;

    for (let node of queue) {
      if (dist[node] < minDist) {
        minDist = dist[node];
        u = node;
      }
    }

    if (!u) break;
    queue.delete(u);

    if (iterations % 1000 === 0) {
      console.log(`Iteration ${iterations}, visiting ${u}, dist=${dist[u]}`);
    }

    if (u === endKey) break;

    visited.add(u);
    for (let neighbor of (graph[u] || [])) {
      if (visited.has(neighbor.node)) continue;
      const alt = dist[u] + neighbor.dist;
      if (alt < (dist[neighbor.node] || Infinity)) {
        dist[neighbor.node] = alt;
        prev[neighbor.node] = u;
        queue.add(neighbor.node);
      }
    }
  }

  if (iterations >= maxIterations) {
    console.warn("❌ Dijkstra aborted: too many iterations or disconnected graph.");
    alert("⚠️ Route search failed: too many steps. This might be due to disconnected trails.");
    return [];
  }

  const path = [];
  let u = endKey;
  while (u) {
    path.unshift(u);
    u = prev[u];
  }

  if (path[0] !== startKey) {
    console.warn("❌ No path could be reconstructed from", startKey, "to", endKey);
    alert("⚠️ Unable to reconstruct route. Trails might be disconnected.");
    return [];
  }

  console.log("✅ Dijkstra finished. Path length:", path.length);
  return path;
}


function drawRoute(path) {
  console.log("Drawing route with", path.length, "points.");
  routeLayers.forEach(l => map.removeLayer(l));
  routeLayers = [];

  const coords = path.map(k => nodeCoords[k]);
  const line = L.polyline(coords, { color: 'orange', weight: 4, pane: 'overlayPane' });
  routeLayers.push(line);
  map.getPane('overlayPane').appendChild(line._path); // add to map without triggering pan/zoom
  line.addTo(map);


  routeLayers.push(line);
  line.addTo(map); // Add the route layer without modifying the view

  // Don't use: map.fitBounds(line.getBounds()); ← Make sure this line doesn't exist

  const totalDist = coords.reduce((sum, _, i) => {
    if (i === 0) return 0;
    return sum + turf.distance(turf.point(coords[i - 1]), turf.point(coords[i]));
  }, 0);

  document.getElementById("distance").textContent = totalDist.toFixed(2);
  document.getElementById("time").textContent = Math.round((totalDist / 5) * 60);
}



map.on("click", e => {
  console.log("Map clicked at", e.latlng);
  const clickedPoint = turf.point([e.latlng.lng, e.latlng.lat]);

  // Find the nearest point on any trail segment
  let nearestPoint = null;
  let minDist = Infinity;

  geojsonData.features.forEach(feature => {
    if (feature.geometry.type === 'LineString') {
      const line = turf.lineString(feature.geometry.coordinates);
      const snapped = turf.nearestPointOnLine(line, clickedPoint, { units: 'kilometers' });
      const dist = snapped.properties.dist;

      if (dist < minDist) {
        minDist = dist;
        nearestPoint = snapped;
      }
    }
  });

  if (!nearestPoint) {
    alert("Could not find a nearby trail to snap to.");
    return;
  }

  const snappedLatLng = L.latLng(nearestPoint.geometry.coordinates[1], nearestPoint.geometry.coordinates[0]);

  if (!startMarker) {
    startMarker = L.marker(snappedLatLng, {
      draggable: true,
      icon: L.icon({ iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/green-dot.png' })
    }).addTo(map);
  } else if (!endMarker) {
    endMarker = L.marker(snappedLatLng, {
      draggable: true,
      icon: L.icon({ iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/red-dot.png' })
    }).addTo(map);

    const startKey = findNearestNode(startMarker.getLatLng());
    const endKey = findNearestNode(endMarker.getLatLng());
    const path = dijkstra(startKey, endKey);
    if (path.length > 0) {
      drawRoute(path);
    } else {
      alert("No path found.");
      console.warn("No path found between", startKey, "and", endKey);
    }
  } else {
    map.removeLayer(startMarker);
    map.removeLayer(endMarker);
    startMarker = null;
    endMarker = null;
    routeLayers.forEach(l => map.removeLayer(l));
    routeLayers = [];
    document.getElementById("distance").textContent = "-";
    document.getElementById("time").textContent = "-";
    document.getElementById("directions").innerHTML = "";
  }
});



navigator.geolocation.getCurrentPosition(pos => {
  userLocation = [pos.coords.latitude, pos.coords.longitude];
  L.marker(userLocation).addTo(map).bindPopup("You are here").openPopup();
  map.setView(userLocation, 14);
});

fetch('map.geojson')
  .then(res => res.json())
  .then(data => {
    geojsonData = data;
    const dropdown = document.getElementById('season-select');
    dropdown.addEventListener('change', () => {
      console.log("Season dropdown changed to:", dropdown.value);
      buildGraph(geojsonData, dropdown.value);
    });
    buildGraph(data, dropdown.value);
  })
  .catch(err => console.error("Failed to load map data:", err));
</script>

</body>
</html>
