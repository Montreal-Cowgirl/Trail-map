<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interactive Trail Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 80vh; width: 100vw; }
    #info { padding: 1rem; background: #f5f5f5; }
    #route-options { margin-top: 1rem; }
    .route-option {
      margin: 4px 0;
      cursor: pointer;
      padding: 4px 8px;
      background: #e0e0e0;
      border-radius: 4px;
    }
    .route-option:hover {
      background: #d0d0d0;
    }
    #season-select {
      margin: 1rem 0;
    }
  </style>
</head>
<body>

<div id="map"></div>
<div id="info">
  <label for="season-select"><strong>Trail Filter:</strong></label>
  <select id="season-select">
    <option value="auto">Auto (Based on Date)</option>
    <option value="summer">Summer Mode</option>
    <option value="winter">Winter Mode</option>
    <option value="all">All Trails</option>
  </select><br/>
  <strong>Distance:</strong> <span id="distance">-</span> km <br />
  <strong>Estimated Time:</strong> <span id="time">-</span> min <br />
  <strong>Directions:</strong>
  <ol id="directions"></ol>
  <div id="route-options"></div>
</div>

<script>
let graph = {}, nodeCoords = {}, geojsonData;
const map = L.map('map').setView([46.8, -71.2], 13);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

let startMarker = null;
let endMarker = null;
let userLocation = null;
let routeLayers = [];

function addEdge(a, b, dist) {
  if (!graph[a]) graph[a] = [];
  graph[a].push({ node: b, dist });
}

function coordKey(coord) {
  return coord[0].toFixed(5) + "," + coord[1].toFixed(5);
}

function getAllowedSeasonKeywords(mode = "auto") {
  if (mode === "all") return null;
  const keywords = ["saison"];
  if (mode === "summer") {
    keywords.push("été");
  } else if (mode === "winter") {
    keywords.push("hiver");
  } else {
    const now = new Date();
    const month = now.getMonth();
    const date = now.getDate();
    const isWinter = (month === 11 && date >= 21) || (month <= 2) || (month === 3 && date <= 30);
    keywords.push(isWinter ? "hiver" : "été");
  }
  return keywords;
}

function normalize(str) {
  return str.normalize("NFD").replace(/\p{Diacritic}/gu, "").toLowerCase();
}

function hasSeasonKeyword(name, allowedKeywords) {
  if (!allowedKeywords) return true;
  const normName = normalize(name || "");
  return allowedKeywords.some(kw => normName.includes(normalize(kw)));
}

function buildGraph(data, seasonMode) {
  graph = {}; nodeCoords = {};
  const allowedKeywords = getAllowedSeasonKeywords(seasonMode);

  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const name = f.properties.name || f.properties.NOM || "";
      if (!hasSeasonKeyword(name, allowedKeywords)) return;

      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        const a = coordKey(coords[i]);
        const b = coordKey(coords[i + 1]);
        const dist = turf.distance(turf.point(coords[i]), turf.point(coords[i + 1]));
        addEdge(a, b, dist);
        addEdge(b, a, dist);
        nodeCoords[a] = coords[i];
        nodeCoords[b] = coords[i + 1];
      }
    }
  });
  console.log(`Graph built for mode: ${seasonMode}`, graph);
  renderGeoJson(data, allowedKeywords);
}

function renderGeoJson(data, allowedKeywords) {
  if (window.trailsLayer) map.removeLayer(window.trailsLayer);
  window.trailsLayer = L.geoJSON(data, {
    filter: f => {
      const name = f.properties.name || f.properties.NOM || "";
      return hasSeasonKeyword(name, allowedKeywords);
    },
    style: { color: 'blue', weight: 3 }
  }).addTo(map);
}

function generateDirections(path) {
  const instructions = [];
  for (let i = 1; i < path.length - 1; i++) {
    const prevCoord = nodeCoords[path[i - 1]];
    const currCoord = nodeCoords[path[i]];
    const nextCoord = nodeCoords[path[i + 1]];

    const prev = turf.point(prevCoord);
    const curr = turf.point(currCoord);
    const next = turf.point(nextCoord);

    const angle1 = turf.bearing(prev, curr);
    const angle2 = turf.bearing(curr, next);
    let angle = Math.abs(angle2 - angle1);
    if (angle > 180) angle = 360 - angle;

    if (angle > 30) {
      const turn = angle2 > angle1 ? "right" : "left";
      const segmentDistance = turf.distance(curr, next, { units: 'kilometers' });
      const roundedDistance = (segmentDistance * 1000).toFixed(0);
      instructions.push(`In ${roundedDistance} meters, turn ${turn}`);
    }
  }
  const dirList = document.getElementById("directions");
  dirList.innerHTML = "";
  instructions.forEach(txt => {
    const li = document.createElement("li");
    li.textContent = txt;
    dirList.appendChild(li);
  });
  return instructions;
}

function findNearestNode(latlng) {
  let nearest = null, minDist = Infinity;
  for (let key in nodeCoords) {
    const coord = nodeCoords[key];
    const dist = turf.distance(turf.point([latlng.lng, latlng.lat]), turf.point(coord));
    if (dist < minDist) {
      minDist = dist;
      nearest = key;
    }
  }
  return nearest;
}

function dijkstra(startKey, endKey) {
  const dist = {}, prev = {}, visited = new Set();
  dist[startKey] = 0;

  while (true) {
    let u = null;
    let minDist = Infinity;
    for (let node in dist) {
      if (!visited.has(node) && dist[node] < minDist) {
        minDist = dist[node];
        u = node;
      }
    }
    if (!u || u === endKey) break;

    visited.add(u);
    for (let neighbor of (graph[u] || [])) {
      const alt = dist[u] + neighbor.dist;
      if (alt < (dist[neighbor.node] || Infinity)) {
        dist[neighbor.node] = alt;
        prev[neighbor.node] = u;
      }
    }
  }

  const path = [];
  let u = endKey;
  while (u) {
    path.unshift(u);
    u = prev[u];
  }
  return path;
}

function drawRoute(path) {
  routeLayers.forEach(l => map.removeLayer(l));
  routeLayers = [];

  const coords = path.map(k => nodeCoords[k]);
  const line = L.polyline(coords, { color: 'orange', weight: 4 }).addTo(map);
  routeLayers.push(line);

  const totalDist = coords.reduce((sum, _, i) => {
    if (i === 0) return 0;
    return sum + turf.distance(turf.point(coords[i - 1]), turf.point(coords[i]));
  }, 0);

  document.getElementById("distance").textContent = totalDist.toFixed(2);
  document.getElementById("time").textContent = Math.round((totalDist / 5) * 60);

  generateDirections(path);
}

map.on("click", e => {
  if (!startMarker) {
    startMarker = L.marker(e.latlng, { draggable: true }).addTo(map).bindPopup("Start").openPopup();
  } else if (!endMarker) {
    endMarker = L.marker(e.latlng, { draggable: true }).addTo(map).bindPopup("End").openPopup();
const startKey = findNearestNode(startMarker.getLatLng());
const endKey = findNearestNode(endMarker.getLatLng());

if (!startKey || !endKey) {
  alert("Start or End point is too far from any trail. Please select a location closer to a trail.");
  console.warn("Invalid node(s):", { startKey, endKey });
  return;
}

const path = dijkstra(startKey, endKey);

if (path.length > 1) {
  drawRoute(path);
} else {
  alert("No path found between selected points.");
  console.warn("Dijkstra returned empty or single-point path.", { startKey, endKey, path });
}

  } else {
    map.removeLayer(startMarker);
    map.removeLayer(endMarker);
    startMarker = null;
    endMarker = null;
    routeLayers.forEach(l => map.removeLayer(l));
    routeLayers = [];
    document.getElementById("distance").textContent = "-";
    document.getElementById("time").textContent = "-";
    document.getElementById("directions").innerHTML = "";
  }
});

navigator.geolocation.getCurrentPosition(pos => {
  userLocation = [pos.coords.latitude, pos.coords.longitude];
  L.marker(userLocation).addTo(map).bindPopup("You are here").openPopup();
  map.setView(userLocation, 14);
});

fetch('map.geojson')
  .then(res => res.json())
  .then(data => {
    geojsonData = data;
    const dropdown = document.getElementById('season-select');
    dropdown.addEventListener('change', () => {
      buildGraph(geojsonData, dropdown.value);
    });
    buildGraph(data, dropdown.value);
  })
  .catch(err => console.error("Failed to load map data:", err));
</script>

</body>
</html>
