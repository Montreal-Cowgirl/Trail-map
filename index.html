<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Trail Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([45.6, -73.935], 13);

    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    let trailSegments = []; // GeoJSON LineString features
    let trailGraph = {};
    let trailLayer;
    let startMarker, endMarker;
    let routeLine;
    const disconnectionThreshold = 25; // meters

    function haversine(lat1, lon1, lat2, lon2) {
      function toRad(x) { return x * Math.PI / 180; }
      const R = 6371e3;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }

    function addToGraph(coord1, coord2, dist) {
      const key1 = coord1.join(',');
      const key2 = coord2.join(',');
      if (!trailGraph[key1]) trailGraph[key1] = [];
      if (!trailGraph[key2]) trailGraph[key2] = [];
      trailGraph[key1].push({ node: key2, dist });
      trailGraph[key2].push({ node: key1, dist });
    }

    function buildGraphFromTrails() {
      trailSegments.forEach(segment => {
        const coords = segment.geometry.coordinates.map(([lng, lat]) => [lat, lng]);
        for (let i = 0; i < coords.length - 1; i++) {
          const dist = haversine(...coords[i], ...coords[i+1]);
          addToGraph(coords[i], coords[i+1], dist);
        }
      });
    }

    function connectNearbySegments(threshold = 25) {
      const allPoints = trailSegments.flatMap(segment => segment.geometry.coordinates.map(([lng, lat]) => [lat, lng]));
      for (let i = 0; i < allPoints.length; i++) {
        for (let j = i + 1; j < allPoints.length; j++) {
          const dist = haversine(...allPoints[i], ...allPoints[j]);
          if (dist > 0 && dist <= threshold) {
            addToGraph(allPoints[i], allPoints[j], dist);
          }
        }
      }
      console.log('✅ Nearby trail segments connected.');
    }

    function highlightDisconnectedEnds(threshold = 25) {
      trailSegments.forEach(segment => {
        const coords = segment.geometry.coordinates.map(([lng, lat]) => [lat, lng]);
        [coords[0], coords[coords.length - 1]].forEach(end => {
          const neighbors = Object.keys(trailGraph).filter(key => haversine(...end, ...key.split(',').map(Number)) <= threshold && key !== end.join(','));
          if (neighbors.length === 0) {
            L.circle(end, { radius: 5, color: 'red', fillColor: 'red', fillOpacity: 1 }).addTo(map);
          }
        });
      });
    }

    function dijkstra(startCoord, endCoord) {
      const startKey = startCoord.join(',');
      const endKey = endCoord.join(',');
      const dist = {}, prev = {}, queue = new Set(Object.keys(trailGraph));
      Object.keys(trailGraph).forEach(node => dist[node] = Infinity);
      dist[startKey] = 0;

      while (queue.size) {
        const u = [...queue].reduce((a, b) => dist[a] < dist[b] ? a : b);
        queue.delete(u);
        if (u === endKey) break;

        trailGraph[u].forEach(({ node: v, dist: w }) => {
          if (!queue.has(v)) return;
          const alt = dist[u] + w;
          if (alt < dist[v]) {
            dist[v] = alt;
            prev[v] = u;
          }
        });
      }

      const path = [];
      for (let u = endKey; u; u = prev[u]) path.unshift(u);
      return path.length ? path : null;
    }

    function renderRoute(path) {
      if (routeLine) map.removeLayer(routeLine);
      const coords = path.map(p => p.split(',').map(Number));
      routeLine = L.polyline(coords, { color: 'green' }).addTo(map);
      console.log('✅ Route drawn');
    }

    function onMapClick(e) {
      if (!startMarker) {
        startMarker = L.marker(e.latlng, {
          icon: L.icon({
            iconUrl: 'https://maps.google.com/mapfiles/ms/icons/green-dot.png',
            iconSize: [32, 32],
            iconAnchor: [16, 32],
          })
        }).addTo(map);
      } else if (!endMarker) {
        endMarker = L.marker(e.latlng, {
          icon: L.icon({
            iconUrl: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png',
            iconSize: [32, 32],
            iconAnchor: [16, 32],
          })
        }).addTo(map);

        const path = dijkstra([startMarker.getLatLng().lat, startMarker.getLatLng().lng], [endMarker.getLatLng().lat, endMarker.getLatLng().lng]);
        if (path) renderRoute(path);
      }
    }

    async function loadTrails() {
      const res = await fetch('trails.geojson');
      const data = await res.json();
      trailSegments = data.features;

      trailLayer = L.geoJSON(data, {
        style: { color: '#0077ff', weight: 3 }
      }).addTo(map);

      buildGraphFromTrails();
      connectNearbySegments(25);
      highlightDisconnectedEnds(25);
      console.log('✅ Trails loaded, graph built, nearby paths connected.');
    }

    map.on('click', onMapClick);
    loadTrails();
  </script>
</body>
</html>
