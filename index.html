<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interactive Trail Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 80vh; width: 100vw; }
    #info { padding: 1rem; background: #f5f5f5; }
    #route-options { margin-top: 1rem; }
  </style>
</head>
<body>

<div id="map"></div>
<div id="info">
  <strong>Distance:</strong> <span id="distance">-</span> km <br />
  <strong>Estimated Time:</strong> <span id="time">-</span> min <br />
  <strong>Directions:</strong>
  <ol id="directions"></ol>
  <div id="route-options"></div> <!-- Area to display available routes -->
</div>

<script>
let map = L.map('map', { doubleClickZoom: false }).setView([45.6362, -74.0345], 15);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

let trailData, graph = {}, nodeCoords = {};
let startMarker, endMarker, clickCount = 0, startNode = null, endNode = null;
let userMarker, routeLine;

function showUserLocation(position) {
  const lat = position.coords.latitude;
  const lng = position.coords.longitude;

  if (userMarker) {
    userMarker.setLatLng([lat, lng]);
  } else {
    userMarker = L.marker([lat, lng]).addTo(map);
    map.setView([lat, lng], 15);
  }
}

function showError(error) {
  console.warn(`ERROR(${error.code}): ${error.message}`);
}

if (navigator.geolocation) {
  navigator.geolocation.watchPosition(showUserLocation, showError, {
    enableHighAccuracy: true,
    maximumAge: 10000,
    timeout: 5000
  });
} else {
  alert("Geolocation is not supported by your browser.");
}

function coordKey(coord) {
  return `${coord[1].toFixed(5)},${coord[0].toFixed(5)}`;
}

function addEdge(a, b, dist) {
  if (!graph[a]) graph[a] = [];
  graph[a].push({ node: b, dist });
}

function buildGraph(data) {
  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        const a = coordKey(coords[i]);
        const b = coordKey(coords[i + 1]);
        const dist = turf.distance(turf.point(coords[i]), turf.point(coords[i + 1]));
        addEdge(a, b, dist);
        addEdge(b, a, dist);
        nodeCoords[a] = coords[i];
        nodeCoords[b] = coords[i + 1];
      }
    }
  });
}

// Enhanced connection logic: connect any segments < 25m apart
function connectNearbySegments(data, threshold = 25) {
  const lineSegments = [];

  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        lineSegments.push([coords[i], coords[i + 1]]);
      }
    }
  });

  for (let i = 0; i < lineSegments.length; i++) {
    for (let j = i + 1; j < lineSegments.length; j++) {
      const line1 = turf.lineString(lineSegments[i]);
      const line2 = turf.lineString(lineSegments[j]);

      const options = { units: 'meters' };
      const dist = turf.pointToLineDistance(turf.midpoint(line1.geometry.coordinates[0], line1.geometry.coordinates[1]), line2, options);

      if (dist <= threshold) {
        const pt1 = turf.nearestPointOnLine(line2, turf.midpoint(line1.geometry.coordinates[0], line1.geometry.coordinates[1]));
        const pt2 = turf.nearestPointOnLine(line1, turf.midpoint(line2.geometry.coordinates[0], line2.geometry.coordinates[1]));

        const a = coordKey(pt1.geometry.coordinates);
        const b = coordKey(pt2.geometry.coordinates);

        const distBetween = turf.distance(pt1, pt2, { units: 'kilometers' });

        nodeCoords[a] = pt1.geometry.coordinates;
        nodeCoords[b] = pt2.geometry.coordinates;

        addEdge(a, b, distBetween);
        addEdge(b, a, distBetween);
      }
    }
  }

  console.log("✅ Nearby trail segments connected.");
}

function findClosestNode(latLng) {
  let minDist = Infinity;
  let closestNode = null;
  const threshold = 100;

  Object.keys(nodeCoords).forEach(key => {
    const nodeLatLng = L.latLng(nodeCoords[key][1], nodeCoords[key][0]);
    const dist = latLng.distanceTo(nodeLatLng);
    if (dist < minDist && dist <= threshold) {
      minDist = dist;
      closestNode = key;
    }
  });

  return closestNode;
}

fetch('map.geojson')
  .then(res => res.json())
  .then(data => {
    trailData = data;
    L.geoJSON(data, { color: 'blue' }).addTo(map);
    buildGraph(data);
    connectNearbySegments(data, 25); // Use 25m threshold
    console.log("✅ Trails loaded, graph built, nearby paths connected.");
  });

map.on('click', function (e) {
  const snapped = findClosestNode(e.latlng);
  if (!snapped) return alert("No nearby trail found.");
  const snappedLatLng = L.latLng(nodeCoords[snapped][1], nodeCoords[snapped][0]);

  // Create the start and end markers with standard pin icons in green and red
  const greenIcon = L.icon({
    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
  });

  const redIcon = L.icon({
    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
  });

  if (clickCount === 0) {
    if (startMarker) map.removeLayer(startMarker);
    startMarker = L.marker(snappedLatLng, { icon: greenIcon }).addTo(map);
    startNode = snapped;
    clickCount++;
  } else {
    if (endMarker) map.removeLayer(endMarker);
    endMarker = L.marker(snappedLatLng, { icon: redIcon }).addTo(map);
    endNode = snapped;
    clickCount = 0;

    // Find the 3 quickest routes
    const routes = findMultipleRoutes(startNode, endNode, 3);
    if (!routes || routes.length === 0) return alert("No path found.");

    renderRouteOptions(routes);
  }
});

// Function to find multiple shortest paths using modified Dijkstra's
function findMultipleRoutes(start, end, numRoutes = 3) {
  const allPaths = [];
  const visitedPaths = new Set();

  function getAngle(p1, p2, p3) {
    const toRadians = deg => deg * Math.PI / 180;
    const toDegrees = rad => rad * 180 / Math.PI;

    const [lat1, lon1] = p1.split(',').map(Number);
    const [lat2, lon2] = p2.split(',').map(Number);
    const [lat3, lon3] = p3.split(',').map(Number);

    const v1 = [lat2 - lat1, lon2 - lon1];
    const v2 = [lat3 - lat2, lon3 - lon2];

    const dot = v1[0]*v2[0] + v1[1]*v2[1];
    const mag1 = Math.hypot(...v1);
    const mag2 = Math.hypot(...v2);
    const angle = Math.acos(dot / (mag1 * mag2));

    return toDegrees(angle);
  }

  function dijkstraWithBlockedEdges(blockedEdges) {
    const distances = {};
    const previous = {};
    const pq = new Set(Object.keys(graph));
    const blockedSet = new Set(blockedEdges.map(edge => `${edge[0]}->${edge[1]}`));

    for (const node in graph) distances[node] = Infinity;
    distances[start] = 0;

    while (pq.size > 0) {
      let current = null;
      for (const node of pq) {
        if (current === null || distances[node] < distances[current]) {
          current = node;
        }
      }

      if (current === end) break;
      pq.delete(current);

      for (const neighbor of graph[current] || []) {
        const edgeKey = `${current}->${neighbor.node}`;
        if (blockedSet.has(edgeKey)) continue;

        const alt = distances[current] + neighbor.dist;
        if (alt < distances[neighbor.node]) {
          distances[neighbor.node] = alt;
          previous[neighbor.node] = current;
        }
      }
    }

    const path = [];
    let current = end;
    while (previous[current]) {
      path.unshift(current);
      current = previous[current];
    }
    if (current === start) {
      path.unshift(start);
      return path;
    }
    return [];
  }

  // First path: baseline route
  const firstPath = dijkstraWithBlockedEdges([]);
  if (firstPath.length) {
    allPaths.push(firstPath);
    visitedPaths.add(firstPath.join('->'));
  } else {
    return allPaths;
  }

  // Identify turning points
  const turnEdges = [];
  for (let i = 1; i < firstPath.length - 1; i++) {
    const angle = getAngle(firstPath[i - 1], firstPath[i], firstPath[i + 1]);
    if (angle < 135) {  // Sharp enough turn
      turnEdges.push([firstPath[i], firstPath[i + 1]]);
    }
  }

  // Try blocking each turn individually to generate new routes
  for (const edge of turnEdges) {
    const newPath = dijkstraWithBlockedEdges([edge]);
    const pathStr = newPath.join('->');
    if (newPath.length && !visitedPaths.has(pathStr)) {
      allPaths.push(newPath);
      visitedPaths.add(pathStr);
      if (allPaths.length >= numRoutes) break;
    }
  }

  console.log("✅ Found multiple routes:", allPaths);
  return allPaths;
}



// Render the available route options for user selection
function renderRouteOptions(routes) {
  const routeOptionsDiv = document.getElementById('route-options');
  routeOptionsDiv.innerHTML = ''; // Clear previous options

  routes.forEach((route, idx) => {
    const routeOption = document.createElement('div');
    routeOption.classList.add('route-option');
    routeOption.textContent = `Route ${idx + 1}: ${route.length} steps`;

    routeOption.onclick = () => {
      console.log(`Route ${idx + 1} selected`);
      renderRoute(route);  // Render the selected route
      renderDirections(route);  // Render the directions for selected route
    };

    routeOptionsDiv.appendChild(routeOption);
  });
}

// Function to render the route
function renderRoute(path) {
  const routeCoords = path.map(node => {
    const coord = nodeCoords[node];
    return [coord[1], coord[0]]; // Leaflet expects [lat, lng]
  });

  if (routeCoords.length > 0) {
    if (routeLine) {
      map.removeLayer(routeLine);
    }

    routeLine = L.polyline(routeCoords, { color: 'green', weight: 5 }).addTo(map);
  } else {
    console.error('No valid route coordinates found.');
  }
}

// Function to render directions for the selected route
function renderDirections(path) {
  const directionsList = document.getElementById('directions');
  directionsList.innerHTML = '';
  let totalDistance = 0;
  let prevBearing = null;
  let prevPoint = null;
  let distanceSinceLastTurn = 0;

  path.forEach((node, idx) => {
    if (idx < path.length - 1) {
      const from = nodeCoords[node];
      const to = nodeCoords[path[idx + 1]];
      const dist = turf.distance(turf.point(from), turf.point(to));
      totalDistance += dist;
      distanceSinceLastTurn += dist;

      const bearing = turf.bearing(turf.point(from), turf.point(to));

      if (prevBearing !== null) {
        let angleChange = bearing - prevBearing;

        if (angleChange > 180) angleChange -= 360;
        if (angleChange < -180) angleChange += 360;

        const absChange = Math.abs(angleChange);

        if (absChange > 25) {
          let direction = '';
          if (absChange > 135) {
            direction = 'Make a U-turn';
          } else if (absChange > 90) {
            direction = angleChange > 0 ? 'Turn sharply right' : 'Turn sharply left';
          } else if (absChange > 30) {
            direction = angleChange > 0 ? 'Turn right' : 'Turn left';
          } else {
            direction = angleChange > 0 ? 'Slight right' : 'Slight left';
          }

          const li = document.createElement('li');
          li.textContent = `${direction} in ${Math.round(distanceSinceLastTurn * 1000)}m`;
          directionsList.appendChild(li);

          distanceSinceLastTurn = 0; // Reset after logging a direction
        }
      }

      prevBearing = bearing;
      prevPoint = from;
    }
  });

  document.getElementById('distance').textContent = totalDistance.toFixed(2);
  document.getElementById('time').textContent = Math.round(totalDistance * 12); // 5 km/h = 12 min/km
}

</script>

</body>
</html>
