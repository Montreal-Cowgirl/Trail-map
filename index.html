<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interactive Trail Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 80vh; width: 100vw; }
    #info { padding: 1rem; background: #f5f5f5; }
    #route-options { margin-top: 1rem; }
  </style>
</head>
<body>

<div id="map"></div>
<div id="info">
  <strong>Distance:</strong> <span id="distance">-</span> km <br />
  <strong>Estimated Time:</strong> <span id="time">-</span> min <br />
  <strong>Directions:</strong>
  <ol id="directions"></ol>
  <div id="route-options"></div> <!-- Area to display available routes -->
</div>

<script>
let map = L.map('map', { doubleClickZoom: false }).setView([45.6362, -74.0345], 15);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

let trailData, graph = {}, nodeCoords = {};
let startMarker, endMarker, clickCount = 0, startNode = null, endNode = null;
let userMarker, routeLine;

function showUserLocation(position) {
  const lat = position.coords.latitude;
  const lng = position.coords.longitude;

  if (userMarker) {
    userMarker.setLatLng([lat, lng]);
  } else {
    userMarker = L.marker([lat, lng]).addTo(map);
    map.setView([lat, lng], 15);
  }
}

function showError(error) {
  console.warn(`ERROR(${error.code}): ${error.message}`);
}

if (navigator.geolocation) {
  navigator.geolocation.watchPosition(showUserLocation, showError, {
    enableHighAccuracy: true,
    maximumAge: 10000,
    timeout: 5000
  });
} else {
  alert("Geolocation is not supported by your browser.");
}

function coordKey(coord) {
  return `${coord[1].toFixed(5)},${coord[0].toFixed(5)}`;
}

function addEdge(a, b, dist) {
  if (!graph[a]) graph[a] = [];
  graph[a].push({ node: b, dist });
}

function buildGraph(data) {
  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        const a = coordKey(coords[i]);
        const b = coordKey(coords[i + 1]);
        const dist = turf.distance(turf.point(coords[i]), turf.point(coords[i + 1]));
        addEdge(a, b, dist);
        addEdge(b, a, dist);
        nodeCoords[a] = coords[i];
        nodeCoords[b] = coords[i + 1];
      }
    }
  });
}

// Remove the connectNearbySegments function to ensure no automatic connections
// Function to find the closest node
function findClosestNode(latLng) {
  let minDist = Infinity;
  let closestNode = null;
  const threshold = 100;

  Object.keys(nodeCoords).forEach(key => {
    const nodeLatLng = L.latLng(nodeCoords[key][1], nodeCoords[key][0]);
    const dist = latLng.distanceTo(nodeLatLng);
    if (dist < minDist && dist <= threshold) {
      minDist = dist;
      closestNode = key;
    }
  });

  return closestNode;
}

fetch('map.geojson')
  .then(res => res.json())
  .then(data => {
    trailData = data;
    L.geoJSON(data, { color: 'blue' }).addTo(map);
    buildGraph(data);
    console.log("✅ Trails loaded, graph built.");
  });

map.on('click', function (e) {
  const snapped = findClosestNode(e.latlng);
  if (!snapped) return alert("No nearby trail found.");
  const snappedLatLng = L.latLng(nodeCoords[snapped][1], nodeCoords[snapped][0]);

  // Create the start and end markers with standard pin icons in green and red
  const greenIcon = L.icon({
    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
  });

  const redIcon = L.icon({
    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
  });

  if (clickCount === 0) {
    if (startMarker) map.removeLayer(startMarker);
    startMarker = L.marker(snappedLatLng, { icon: greenIcon }).addTo(map);
    startNode = snapped;
    clickCount++;
  } else {
    if (endMarker) map.removeLayer(endMarker);
    endMarker = L.marker(snappedLatLng, { icon: redIcon }).addTo(map);
    endNode = snapped;
    clickCount = 0;

    // Find the 3 quickest routes
    const routes = findMultipleRoutes(startNode, endNode, 3);
    if (!routes || routes.length === 0) return alert("No path found.");

    renderRouteOptions(routes);
  }
});


  // Function to calculate the angle between three points
function getAngle(start, middle, end) {
  const startLatLng = L.latLng(nodeCoords[start][1], nodeCoords[start][0]);
  const middleLatLng = L.latLng(nodeCoords[middle][1], nodeCoords[middle][0]);
  const endLatLng = L.latLng(nodeCoords[end][1], nodeCoords[end][0]);

  const angle1 = Math.atan2(middleLatLng.lat - startLatLng.lat, middleLatLng.lng - startLatLng.lng);
  const angle2 = Math.atan2(endLatLng.lat - middleLatLng.lat, endLatLng.lng - middleLatLng.lng);

  const angle = (angle2 - angle1) * (180 / Math.PI);
  return Math.abs(angle);
}

  // Function to find multiple shortest paths using modified Dijkstra's
function findMultipleRoutes(start, end, numRoutes = 3) {
  const allPaths = [];
  const visitedPaths = new Set();

  function dijkstraWithBlockedEdges(blockedEdges) {
    const distances = {};
    const previous = {};
    const pq = new Set(Object.keys(graph));
    const blockedSet = new Set(blockedEdges.map(edge => `${edge[0]}->${edge[1]}`));

    for (const node in graph) distances[node] = Infinity;
    distances[start] = 0;

    while (pq.size > 0) {
      let current = null;
      for (const node of pq) {
        if (current === null || distances[node] < distances[current]) {
          current = node;
        }
      }

      if (current === end) break;
      pq.delete(current);

      for (const neighbor of graph[current] || []) {
        const edgeKey = `${current}->${neighbor.node}`;
        if (blockedSet.has(edgeKey)) continue;

        const alt = distances[current] + neighbor.dist;
        if (alt < distances[neighbor.node]) {
          distances[neighbor.node] = alt;
          previous[neighbor.node] = current;
        }
      }
    }

    const path = [];
    let current = end;
    while (previous[current]) {
      path.unshift(current);
      current = previous[current];
    }
    if (current === start) {
      path.unshift(start);
      return path;
    }
    return [];
  }

  // First path: baseline route
  const firstPath = dijkstraWithBlockedEdges([]);
  if (firstPath.length) {
    allPaths.push(firstPath);
    visitedPaths.add(firstPath.join('->'));
  } else {
    return allPaths;
  }

  // Identify turning points
  const turnEdges = [];
  for (let i = 1; i < firstPath.length - 1; i++) {
    const angle = getAngle(firstPath[i - 1], firstPath[i], firstPath[i + 1]);
    if (angle < 135) {  // Sharp enough turn
      turnEdges.push([firstPath[i], firstPath[i + 1]]);
    }
  }

  // Try blocking each turn individually to generate new routes
  for (const edge of turnEdges) {
    const newPath = dijkstraWithBlockedEdges([edge]);
    const pathStr = newPath.join('->');
    if (newPath.length && !visitedPaths.has(pathStr)) {
      allPaths.push(newPath);
      visitedPaths.add(pathStr);
      if (allPaths.length >= numRoutes) break;
    }
  }

  console.log("✅ Found multiple routes:", allPaths);
  return allPaths;
}

// Render the available route options for user selection
function renderRouteOptions(routes) {
  const routeOptionsDiv = document.getElementById("route-options");
  routeOptionsDiv.innerHTML = "<h4>Select a Route:</h4>";

  routes.forEach((route, index) => {
    const routeLabel = `Route ${index + 1}`;
    const routeButton = document.createElement('button');
    routeButton.textContent = routeLabel;
    routeButton.onclick = () => drawRoute(route);
    routeOptionsDiv.appendChild(routeButton);
  });
}

// Render a selected route on the map
function drawRoute(route) {
  if (routeLine) map.removeLayer(routeLine);
  const latlngs = route.map(node => nodeCoords[node]);
  routeLine = L.polyline(latlngs, { color: 'orange', weight: 5 }).addTo(map);

  const totalDist = route.reduce((dist, node, index) => {
    if (index === 0) return dist;
    const prevNode = route[index - 1];
    return dist + graph[node].find(n => n.node === prevNode).dist;
  }, 0);

  const time = (totalDist / 5) * 60; // Assume average speed of 5 km/h
  document.getElementById('distance').textContent = (totalDist / 1000).toFixed(2);
  document.getElementById('time').textContent = Math.round(time);
  displayDirections(route);
}

// Display directions for a selected route
function displayDirections(route) {
  const directionsList = document.getElementById("directions");
  directionsList.innerHTML = "";

  for (let i = 0; i < route.length - 1; i++) {
    const start = route[i];
    const end = route[i + 1];
    const direction = `${nodeCoords[start].join(', ')} → ${nodeCoords[end].join(', ')}`;
    const li = document.createElement('li');
    li.textContent = direction;
    directionsList.appendChild(li);
  }
}
</script>

</body>
</html>
