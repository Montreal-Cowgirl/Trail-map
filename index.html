<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Interactive Trail Map v1.002</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <style>
    #map { height: 90vh; width: 100%; }
    #info { padding: 10px; font-family: Arial, sans-serif; }
    .controls { margin-bottom: 10px; }
    .route-option { margin-bottom: 10px; padding: 5px; border: 1px solid #ccc; }
  </style>
</head>
<body>
  <div class="controls">
    <label><input type="radio" name="season" value="all" checked> Tous</label>
    <label><input type="radio" name="season" value="ete"> Été + Saison</label>
    <label><input type="radio" name="season" value="hiver"> Hiver + Saison</label>
  </div>
  <div id="map"></div>
  <div id="info"></div>

  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <script>
    const map = L.map('map').setView([46.8, -71.2], 12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
    }).addTo(map);

    const trailLayer = L.geoJSON(null, { style: { color: 'blue', weight: 3 } }).addTo(map);
    let startMarker = null;
    let endMarker = null;
    let routeLayers = [];
    let clickState = 0;

    let trailData = null;
    let graph = {};
    const turnPenalty = 0.001;
    const routeSimilarityThreshold = 0.85;

    fetch('map.geojson')
      .then(res => res.json())
      .then(data => {
        trailData = data;
        updateTrailLayer('all');
        buildGraph(trailData);
      });

    function updateTrailLayer(seasonMode) {
      trailLayer.clearLayers();
      trailLayer.addData(filterTrailsBySeason(trailData, seasonMode));
    }

    function filterTrailsBySeason(data, mode) {
      return {
        type: 'FeatureCollection',
        features: data.features.filter(f => {
          const type = f.properties.type;
          if (mode === 'all') return true;
          if (mode === 'ete') return type === 'été' || type === 'saison';
          if (mode === 'hiver') return type === 'hiver' || type === 'saison';
        })
      };
    }

    document.querySelectorAll('input[name="season"]').forEach(input => {
      input.addEventListener('change', () => {
        updateTrailLayer(input.value);
        buildGraph(filterTrailsBySeason(trailData, input.value));
      });
    });

    function buildGraph(geojson) {
      graph = {};
      geojson.features.forEach(feature => {
        const coords = feature.geometry.coordinates;
        for (let i = 0; i < coords.length - 1; i++) {
          const a = coords[i].join(',');
          const b = coords[i + 1].join(',');
          const dist = turf.distance(turf.point(coords[i]), turf.point(coords[i + 1]));
          if (!graph[a]) graph[a] = [];
          if (!graph[b]) graph[b] = [];
          graph[a].push({ node: b, weight: dist });
          graph[b].push({ node: a, weight: dist });
        }
      });
    }

    map.on('click', e => {
      const clickedPoint = turf.point([e.latlng.lng, e.latlng.lat]);
      const snapped = turf.nearestPointOnLine(trailLayer.toGeoJSON(), clickedPoint);
      const snappedLatLng = L.latLng(snapped.geometry.coordinates[1], snapped.geometry.coordinates[0]);

      if (clickState === 0) {
        if (startMarker) map.removeLayer(startMarker);
        startMarker = L.marker(snappedLatLng, { icon: L.icon({ iconUrl: 'http://maps.google.com/mapfiles/ms/icons/green-dot.png' }) }).addTo(map);
        clickState = 1;
      } else if (clickState === 1) {
        if (endMarker) map.removeLayer(endMarker);
        endMarker = L.marker(snappedLatLng, { icon: L.icon({ iconUrl: 'http://maps.google.com/mapfiles/ms/icons/red-dot.png' }) }).addTo(map);
        renderRouteOptions(startMarker.getLatLng(), endMarker.getLatLng());
        clickState = 2;
      } else {
        map.removeLayer(startMarker);
        map.removeLayer(endMarker);
        routeLayers.forEach(layer => map.removeLayer(layer));
        document.getElementById('info').innerHTML = '';
        clickState = 0;
      }
    });

    function renderRouteOptions(startLatLng, endLatLng) {
      const start = startLatLng.lng + ',' + startLatLng.lat;
      const end = endLatLng.lng + ',' + endLatLng.lat;
      const routes = findMultipleRoutes(start, end, 3);

      routeLayers.forEach(layer => map.removeLayer(layer));
      routeLayers = [];
      document.getElementById('info').innerHTML = '';

      routes.forEach((path, i) => {
        const latlngs = path.map(p => L.latLng(parseFloat(p.split(',')[1]), parseFloat(p.split(',')[0])));
        const layer = L.polyline(latlngs, { color: i === 0 ? 'red' : i === 1 ? 'orange' : 'purple', weight: 4 }).addTo(map);
        routeLayers.push(layer);

        const line = turf.lineString(path.map(p => p.split(',').map(Number)));
        const dist = turf.length(line);
        const time = (dist / 5 * 60).toFixed(0);
        const div = document.createElement('div');
        div.className = 'route-option';
        div.innerHTML = `<strong>Route ${i + 1}</strong><br>Distance: ${dist.toFixed(2)} km<br>Temps estimé: ${time} min`;
        document.getElementById('info').appendChild(div);
      });
    }

    function aStarWithBlockedEdges(start, end, blockedEdges) {
      const openSet = new Set([start]);
      const cameFrom = {};
      const gScore = { [start]: 0 };
      const fScore = { [start]: turf.distance(turf.point(start.split(',').map(Number)), turf.point(end.split(',').map(Number))) };

      while (openSet.size > 0) {
        let current = [...openSet].reduce((a, b) => fScore[a] < fScore[b] ? a : b);
        if (current === end) {
          const path = [];
          while (current) {
            path.unshift(current);
            current = cameFrom[current];
          }
          return path;
        }
        openSet.delete(current);
        for (const neighbor of graph[current] || []) {
          const edgeKey = current + '|' + neighbor.node;
          const revEdgeKey = neighbor.node + '|' + current;
          if (blockedEdges.has(edgeKey) || blockedEdges.has(revEdgeKey)) continue;
          const tentative = gScore[current] + neighbor.weight + turnPenalty;
          if (tentative < (gScore[neighbor.node] || Infinity)) {
            cameFrom[neighbor.node] = current;
            gScore[neighbor.node] = tentative;
            fScore[neighbor.node] = tentative + turf.distance(turf.point(neighbor.node.split(',').map(Number)), turf.point(end.split(',').map(Number)));
            openSet.add(neighbor.node);
          }
        }
      }
      return [];
    }

    function findMultipleRoutes(start, end, numRoutes = 3) {
      const routes = [];
      const blockedEdges = new Set();

      for (let i = 0; i < numRoutes; i++) {
        const path = aStarWithBlockedEdges(start, end, blockedEdges);
        if (path.length === 0) break;

        if (!routes.some(existing => calculateRouteOverlap(existing, path) > routeSimilarityThreshold)) {
          routes.push(path);

          for (let j = 0; j < path.length - 1; j++) {
            const key = path[j] + '|' + path[j + 1];
            blockedEdges.add(key);
          }
        } else {
          break;
        }
      }
      return routes;
    }

    function calculateRouteOverlap(route1, route2) {
      const set1 = new Set(route1);
      const set2 = new Set(route2);
      const intersection = [...set1].filter(x => set2.has(x));
      return intersection.length / Math.min(route1.length, route2.length);
    }
  </script>
</body>
</html>
