<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interactive Trail Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 80vh; width: 100vw; }
    #info { padding: 1rem; background: #f5f5f5; }
    #route-options { margin-top: 1rem; }
    .route-option {
      margin: 4px 0;
      cursor: pointer;
      padding: 4px 8px;
      background: #e0e0e0;
      border-radius: 4px;
    }
    .route-option:hover {
      background: #d0d0d0;
    }
  </style>
</head>
<body>

<div id="map"></div>
<div id="info">
  <strong>Distance:</strong> <span id="distance">-</span> km <br />
  <strong>Estimated Time:</strong> <span id="time">-</span> min <br />
  <strong>Directions:</strong>
  <ol id="directions"></ol>
  <div id="route-options"></div>
</div>

<script>
let map = L.map('map', { doubleClickZoom: false }).setView([45.6362, -74.0345], 15);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

let trailData, graph = {}, nodeCoords = {};
let startMarker, endMarker, clickCount = 0, startNode = null, endNode = null;
let userMarker, routeLine;
let previewLines = [];

function coordKey(coord) {
  return `${coord[1].toFixed(5)},${coord[0].toFixed(5)}`;
}

function addEdge(a, b, dist, isNearby = false) {
  if (!graph[a]) graph[a] = [];
  const adjustedDist = isNearby ? dist + 0.2 : dist;
  graph[a].push({ node: b, dist: adjustedDist });
}

function buildGraph(data) {
  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        const a = coordKey(coords[i]);
        const b = coordKey(coords[i + 1]);
        const dist = turf.distance(turf.point(coords[i]), turf.point(coords[i + 1]));
        addEdge(a, b, dist);
        addEdge(b, a, dist);
        nodeCoords[a] = coords[i];
        nodeCoords[b] = coords[i + 1];
      }
    }
  });
}

function connectNearbySegments(data, threshold = 25) {
  const lineSegments = [];
  data.features.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        lineSegments.push([coords[i], coords[i + 1]]);
      }
    }
  });

  const seenPairs = new Set();

  for (let i = 0; i < lineSegments.length; i++) {
    for (let j = i + 1; j < lineSegments.length; j++) {
      const idPair = `${i}-${j}`;
      if (seenPairs.has(idPair)) continue;
      seenPairs.add(idPair);

      const line1 = turf.lineString(lineSegments[i]);
      const line2 = turf.lineString(lineSegments[j]);
      const mid1 = turf.midpoint(line1.geometry.coordinates[0], line1.geometry.coordinates[1]);
      const mid2 = turf.midpoint(line2.geometry.coordinates[0], line2.geometry.coordinates[1]);
      const dist = turf.distance(mid1, mid2, { units: 'meters' });

      if (dist <= threshold) {
        const pt1 = turf.nearestPointOnLine(line2, mid1);
        const pt2 = turf.nearestPointOnLine(line1, mid2);

        const a = coordKey(pt1.geometry.coordinates);
        const b = coordKey(pt2.geometry.coordinates);
        const distBetween = turf.distance(pt1, pt2);

        // Reject jumps if distance < threshold but direction angles differ wildly (to avoid jumping at forks)
        const bearing1 = turf.bearing(line1.geometry.coordinates[0], line1.geometry.coordinates[1]);
        const bearing2 = turf.bearing(line2.geometry.coordinates[0], line2.geometry.coordinates[1]);
        const angleDiff = Math.abs(bearing1 - bearing2);
        if (angleDiff > 30) continue;

        console.log(`Connecting nearby segments between ${a} and ${b}, dist=${(distBetween * 1000).toFixed(1)}m, angleDiff=${angleDiff.toFixed(1)}Â°`);

        nodeCoords[a] = pt1.geometry.coordinates;
        nodeCoords[b] = pt2.geometry.coordinates;
        addEdge(a, b, distBetween, true);
        addEdge(b, a, distBetween, true);
      }
    }
  }
}

function findClosestNode(latLng) {
  let minDist = Infinity, closestNode = null, threshold = 100;
  Object.keys(nodeCoords).forEach(key => {
    const nodeLatLng = L.latLng(nodeCoords[key][1], nodeCoords[key][0]);
    const dist = latLng.distanceTo(nodeLatLng);
    if (dist < minDist && dist <= threshold) {
      minDist = dist;
      closestNode = key;
    }
  });
  return closestNode;
}

fetch('map.geojson')
  .then(res => res.json())
  .then(data => {
    trailData = data;
    L.geoJSON(data, { color: 'blue' }).addTo(map);
    buildGraph(data);
    connectNearbySegments(data, 25);
  });

map.on('click', function (e) {
  const snapped = findClosestNode(e.latlng);
  if (!snapped) return alert("No nearby trail found.");
  const snappedLatLng = L.latLng(nodeCoords[snapped][1], nodeCoords[snapped][0]);

  const greenIcon = L.icon({
    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
    iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
  });
  const redIcon = L.icon({
    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
    iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
  });

  if (clickCount === 0) {
    if (startMarker) map.removeLayer(startMarker);
    startMarker = L.marker(snappedLatLng, { icon: greenIcon }).addTo(map);
    startNode = snapped;
    clickCount++;
  } else {
    if (endMarker) map.removeLayer(endMarker);
    endMarker = L.marker(snappedLatLng, { icon: redIcon }).addTo(map);
    endNode = snapped;
    clickCount = 0;
    alert("Start and end set. Routing logic not included in this version.");
  }
});
</script>

</body>
</html>
