<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interactive Trail Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 80vh; width: 100vw; }
    #info { padding: 1rem; background: #f5f5f5; }
    #route-options { margin-top: 1rem; }
    .route-option {
      margin: 4px 0;
      cursor: pointer;
      padding: 4px 8px;
      background: #e0e0e0;
      border-radius: 4px;
    }
    .route-option:hover {
      background: #d0d0d0;
    }
    #season-select {
      margin: 1rem 0;
    }
  </style>
</head>
<body>

<div id="map"></div>
<div id="info">
  <label for="season-select"><strong>Trail Filter:</strong></label>
  <select id="season-select">
    <option value="auto">Auto (Based on Date)</option>
    <option value="summer">Summer Mode</option>
    <option value="winter">Winter Mode</option>
    <option value="all">All Trails</option>
  </select><br/>
  <strong>Distance:</strong> <span id="distance">-</span> km <br />
  <strong>Estimated Time:</strong> <span id="time">-</span> min <br />
  <strong>Directions:</strong>
  <ol id="directions"></ol>
  <div id="route-options"></div>
</div>

<script>
let trailLayer = null;
let trailLayerGroup = null;
let graph = {}, nodeCoords = {}, geojsonData;
const map = L.map('map').setView([46.8, -71.2], 13);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

let startMarker = null;
let endMarker = null;
let userLocation = null;
let routeLayers = [];

function addEdge(a, b, dist) {
  if (!graph[a]) graph[a] = [];
  graph[a].push({ node: b, dist });
}

function coordKey(coord) {
  return coord[0].toFixed(5) + "," + coord[1].toFixed(5);
}

function getAllowedSeasonKeywords(mode = "auto") {
  if (mode === "all") return null;
  const keywords = ["saison"];
  if (mode === "summer") {
    keywords.push("√©t√©");
  } else if (mode === "winter") {
    keywords.push("hiver");
  } else {
    const now = new Date();
    const month = now.getMonth();
    const date = now.getDate();
    const isWinter = (month === 11 && date >= 21) || (month <= 2) || (month === 3 && date <= 30);
    keywords.push(isWinter ? "hiver" : "√©t√©");
  }
  return keywords;
}

function normalize(str) {
  return str.normalize("NFD").replace(/\p{Diacritic}/gu, "").toLowerCase();
}

function hasSeasonKeyword(name, allowedKeywords) {
  if (!allowedKeywords) return true;
  const normName = normalize(name || "");
  return allowedKeywords.some(kw => normName.includes(normalize(kw)));
}

function buildGraph(data, seasonMode = "auto") {
  console.log("üîß Building graph for season mode:", seasonMode);
  graph = {};

  const allowedKeywords = getAllowedSeasonKeywords(seasonMode);
  let skipped = 0;
  let endpoints = [];

  data.features.forEach(feature => {
    const name = feature.properties.name || feature.properties.NOM || "";
    if (!hasSeasonKeyword(name, allowedKeywords)) {
      skipped++;
      return;
    }

    const coords = feature.geometry.coordinates;
    for (let i = 0; i < coords.length - 1; i++) {
      const a = coords[i], b = coords[i + 1];
      const dist = turf.distance(turf.point(a), turf.point(b));

      const keyA = a.join(","), keyB = b.join(",");
      if (!graph[keyA]) graph[keyA] = [];
      if (!graph[keyB]) graph[keyB] = [];

      graph[keyA].push({ node: keyB, dist });
      graph[keyB].push({ node: keyA, dist });
    }

    // Collect start and end points for connectivity fix
    if (coords.length >= 2) {
      endpoints.push(turf.point(coords[0]));
      endpoints.push(turf.point(coords[coords.length - 1]));
    }
  });

  // Fix: Ensure endpoints are connected if close enough
  const endpointPairs = turf.featureCollection(endpoints);
  for (let i = 0; i < endpoints.length; i++) {
    for (let j = i + 1; j < endpoints.length; j++) {
      const ptA = endpoints[i], ptB = endpoints[j];
      const d = turf.distance(ptA, ptB, { units: 'kilometers' });

      if (d < 0.01) { // ~10 meters
        const keyA = ptA.geometry.coordinates.join(",");
        const keyB = ptB.geometry.coordinates.join(",");

        if (keyA !== keyB) {
          const dist = d;
          if (!graph[keyA]) graph[keyA] = [];
          if (!graph[keyB]) graph[keyB] = [];

          graph[keyA].push({ node: keyB, dist });
          graph[keyB].push({ node: keyA, dist });
        }
      }
    }
  }

  console.log(`‚úÖ Graph built with ${Object.keys(graph).length} connections and ${skipped} skipped features.`);
}

function traverseGraphFrom(startKey, graph) {
  const visited = new Set();
  const queue = [startKey];
  while (queue.length > 0) {
    const node = queue.shift();
    if (visited.has(node)) continue;
    visited.add(node);
    for (let neighbor of (graph[node] || [])) {
      queue.push(neighbor.node);
    }
  }
  return visited;
}



function displayFilteredTrails() {
  // Remove old trail layer if it exists
  if (trailLayerGroup) {
    map.removeLayer(trailLayerGroup);
  }

  const allowedKeywords = getAllowedSeasonKeywords(document.getElementById('season-select').value);

  const visibleFeatures = geojsonData.features.filter(f => {
    const name = f.properties.name || f.properties.NOM || "";
    return hasSeasonKeyword(name, allowedKeywords); // ‚úÖ Apply filtering here
  });

  trailLayerGroup = L.geoJSON({ type: 'FeatureCollection', features: visibleFeatures }, {
    style: {
      color: "#3388ff",
      weight: 3
    }
  }).addTo(map);
}


function renderGeoJson(data, allowedKeywords) {
  if (window.trailsLayer) map.removeLayer(window.trailsLayer);
  window.trailsLayer = L.geoJSON(data, {
    filter: f => {
      const name = f.properties.name || f.properties.NOM || "";
      return hasSeasonKeyword(name, allowedKeywords);
    },
    style: { color: 'blue', weight: 3 }
  }).addTo(map);
}

function generateDirections(path) {
  console.log("Generating directions for path of length:", path.length);
  const instructions = [];
  for (let i = 1; i < path.length - 1; i++) {
    const prevCoord = nodeCoords[path[i - 1]];
    const currCoord = nodeCoords[path[i]];
    const nextCoord = nodeCoords[path[i + 1]];

    const prev = turf.point(prevCoord);
    const curr = turf.point(currCoord);
    const next = turf.point(nextCoord);

    const angle1 = turf.bearing(prev, curr);
    const angle2 = turf.bearing(curr, next);
    let angle = Math.abs(angle2 - angle1);
    if (angle > 180) angle = 360 - angle;

    if (angle > 30) {
      const turn = angle2 > angle1 ? "right" : "left";
      const segmentDistance = turf.distance(curr, next, { units: 'kilometers' });
      const roundedDistance = (segmentDistance * 1000).toFixed(0);
      instructions.push(`In ${roundedDistance} meters, turn ${turn}`);
    }
  }
  const dirList = document.getElementById("directions");
  dirList.innerHTML = "";
  instructions.forEach(txt => {
    const li = document.createElement("li");
    li.textContent = txt;
    dirList.appendChild(li);
  });
  return instructions;
}

function findNearestNode(latlng) {
  let nearest = null, minDist = Infinity;
  for (let key in nodeCoords) {
    const coord = nodeCoords[key];
    const dist = turf.distance(turf.point([latlng.lng, latlng.lat]), turf.point(coord));
    if (dist < minDist) {
      minDist = dist;
      nearest = key;
    }
  }
  console.log("Nearest node to", latlng, "is", nearest, "at distance", minDist);
  return nearest;
}


function addTemporaryNodeToGraph(snappedPoint) {
  const tempKey = coordKey([snappedPoint.lng, snappedPoint.lat]);
  let closestSegment = null;
  let minDist = Infinity;
  let maxAcceptableDist = 0.01; // ~10 meters in kilometers

  // Try to find the closest segment
  geojsonData.features.forEach(f => {
    if (f.geometry.type === "LineString") {
      const coords = f.geometry.coordinates;
      for (let i = 0; i < coords.length - 1; i++) {
        const a = coords[i];
        const b = coords[i + 1];
        const line = turf.lineString([a, b]);
        const dist = turf.pointToLineDistance(
          turf.point([snappedPoint.lng, snappedPoint.lat]),
          line,
          { units: 'kilometers' }
        );
        if (dist < minDist) {
          minDist = dist;
          closestSegment = { a, b };
        }
      }
    }
  });

  if (!closestSegment || minDist > maxAcceptableDist) {
    console.warn(`‚ùå Could not find a nearby graph segment to connect to for point ${tempKey}`);
    alert("‚ö†Ô∏è Couldn't find a nearby trail segment to connect your clicked point.");
    return null;
  }

  const { a, b } = closestSegment;
  const distToA = turf.distance(turf.point(a), turf.point([snappedPoint.lng, snappedPoint.lat]));
  const distToB = turf.distance(turf.point(b), turf.point([snappedPoint.lng, snappedPoint.lat]));

  const aKey = coordKey(a);
  const bKey = coordKey(b);

  // Add temp node and edges
  graph[tempKey] = [
    { node: aKey, dist: distToA },
    { node: bKey, dist: distToB }
  ];
  if (!graph[aKey]) graph[aKey] = [];
  if (!graph[bKey]) graph[bKey] = [];
  graph[aKey].push({ node: tempKey, dist: distToA });
  graph[bKey].push({ node: tempKey, dist: distToB });

  nodeCoords[tempKey] = [snappedPoint.lng, snappedPoint.lat];

  console.log(`‚úÖ Added temp node ${tempKey} connected to ${aKey} and ${bKey}`);
  return tempKey;
}





  function addSnappedPointToGraph(latlng) {
  const pt = turf.point([latlng.lng, latlng.lat]);
  let minDist = Infinity;
  let snappedCoord = null;
  let segmentEnds = [];

  geojsonData.features.forEach(f => {
    if (f.geometry.type === "LineString") {
      const line = turf.lineString(f.geometry.coordinates);
      const snapped = turf.nearestPointOnLine(line, pt);
      if (snapped.properties.dist < minDist) {
        minDist = snapped.properties.dist;
        snappedCoord = snapped.geometry.coordinates;

        const segIndex = snapped.properties.index;
        const coords = f.geometry.coordinates;

        if (segIndex < coords.length - 1) {
          segmentEnds = [coords[segIndex], coords[segIndex + 1]];
        }
      }
    }
  });

  if (!snappedCoord || segmentEnds.length !== 2) {
    console.warn("Snapping failed.");
    return null;
  }

  const keySnapped = coordKey(snappedCoord);
  nodeCoords[keySnapped] = snappedCoord;

  const [a, b] = segmentEnds;
  const keyA = coordKey(a);
  const keyB = coordKey(b);

  // Add bidirectional edges to the graph
  const distA = turf.distance(turf.point(a), turf.point(snappedCoord));
  const distB = turf.distance(turf.point(b), turf.point(snappedCoord));
  addEdge(keyA, keySnapped, distA);
  addEdge(keySnapped, keyA, distA);
  addEdge(keyB, keySnapped, distB);
  addEdge(keySnapped, keyB, distB);

  return keySnapped;
}
//const reachable = traverseGraphFrom(startKey);
//console.log("üåê Reachable nodes from startKey:", reachable.size);
//console.log("üîé Does it include endKey?", reachable.has(endKey));


function dijkstra(startKey, endKey) {
  // Debug: Log graph connectivity of start and end
  console.log("üìå Checking graph connectivity for start and end:");
  console.log(`StartKey: ${startKey}, Exists: ${graph[startKey] !== undefined}, Connections:`, graph[startKey]);
  console.log(`EndKey: ${endKey}, Exists: ${graph[endKey] !== undefined}, Connections:`, graph[endKey]);
  console.log("Running Dijkstra from", startKey, "to", endKey);
  const dist = {}, prev = {}, visited = new Set();
  dist[startKey] = 0;

  let iterations = 0, maxIterations = 20000;
  const queue = new Set([startKey]);

  while (queue.size > 0 && iterations++ < maxIterations) {
    let u = null;
    let minDist = Infinity;

    for (let node of queue) {
      if (dist[node] < minDist) {
        minDist = dist[node];
        u = node;
      }
    }

    if (!u) break;
    queue.delete(u);

    if (iterations % 1000 === 0) {
      console.log(`Iteration ${iterations}, visiting ${u}, dist=${dist[u]}`);
    }

    if (u === endKey) break;

    visited.add(u);
    for (let neighbor of (graph[u] || [])) {
      if (visited.has(neighbor.node)) continue;
      const alt = dist[u] + neighbor.dist;
      if (alt < (dist[neighbor.node] || Infinity)) {
        dist[neighbor.node] = alt;
        prev[neighbor.node] = u;
        queue.add(neighbor.node);
      }
    }
  }

  if (iterations >= maxIterations) {
    console.warn("‚ùå Dijkstra aborted: too many iterations or disconnected graph.");
    alert("‚ö†Ô∏è Route search failed: too many steps. This might be due to disconnected trails.");
    return [];
  }

  let u = endKey;
  while (u) {
    path.unshift(u);
    u = prev[u];
  }

  if (path[0] !== startKey) {
    console.warn("‚ùå No path could be reconstructed from", startKey, "to", endKey);
    alert("‚ö†Ô∏è Unable to reconstruct route. Trails might be disconnected.");
    return [];
  }

  console.log("‚úÖ Dijkstra finished. Path length:", path.length);
  return path;
}


function drawRoute(path) {
  console.log("Drawing route with", path.length, "points.");
  
  // Clear previous route layers
  routeLayers.forEach(l => map.removeLayer(l));
  routeLayers = [];

  const coords = path.map(k => {
    const coord = nodeCoords[k];

    if (!coord) {
      console.warn("Missing nodeCoords for key:", k);
      return null;
    }

    // Normalize to [lat, lng] format for Leaflet
    if (Array.isArray(coord)) {
      // coord is [lng, lat] or [lng, lat, ...]
      const lng = coord[0];
      const lat = coord[1];
      return [lat, lng];
    }

    // If somehow stored as GeoJSON Point
    if (coord.type === "Point" && Array.isArray(coord.coordinates)) {
      const [lng, lat] = coord.coordinates;
      return [lat, lng];
    }

    console.warn("Invalid coordinate format for key:", k, "‚Üí", coord);
    return null;
  }).filter(Boolean);

  console.log("Route coordinates:", coords);

  if (coords.length < 2) {
    console.warn("Not enough valid coordinates to draw route.");
    return;
  }

  // Draw route
  const line = L.polyline(coords, { color: 'orange', weight: 4 }).addTo(map);
  routeLayers.push(line);

  // Calculate and display distance and estimated time
  const totalDist = coords.reduce((sum, _, i) => {
    if (i === 0) return 0;
    return sum + turf.distance(turf.point([coords[i - 1][1], coords[i - 1][0]]), turf.point([coords[i][1], coords[i][0]]));
  }, 0);

  document.getElementById("distance").textContent = totalDist.toFixed(2);
  document.getElementById("time").textContent = Math.round((totalDist / 5) * 60); // 5 km/h
}



map.on("click", e => {
  console.log("Map clicked at", e.latlng);

  const clickPoint = turf.point([e.latlng.lng, e.latlng.lat]);
  const allowedKeywords = getAllowedSeasonKeywords(document.getElementById('season-select').value);

  let minDist = Infinity;
  let snappedPoint = null;

  // Step 1: Filter features by season and snap click to nearest trail
  const filteredFeatures = geojsonData.features.filter(f => {
    const name = f.properties.name || f.properties.NOM || "";
    return hasSeasonKeyword(name, allowedKeywords);
  });

  filteredFeatures.forEach(f => {
    if (f.geometry.type === 'LineString') {
      const line = turf.lineString(f.geometry.coordinates);
      const candidate = turf.nearestPointOnLine(line, clickPoint, { units: 'kilometers' });
      const dist = turf.pointToLineDistance(clickPoint, line, { units: 'kilometers' });

      if (dist < minDist) {
        minDist = dist;
        snappedPoint = candidate;
      }
    }
  });

  if (!snappedPoint) {
    alert("‚ùå No nearby trail segment found.");
    return;
  }

  const snappedLatLng = L.latLng(
    snappedPoint.geometry.coordinates[1],
    snappedPoint.geometry.coordinates[0]
  );

  // CASE 1: Set Start Marker
  if (!startMarker) {
    startMarker = L.marker(snappedLatLng, {
      draggable: false,
      icon: L.icon({
        iconUrl: 'https://maps.google.com/mapfiles/ms/icons/green-dot.png',
        iconSize: [32, 32],
        iconAnchor: [16, 32]
      })
    }).addTo(map);

    const startKey = addSnappedPointToGraph(snappedLatLng);
    if (!startKey) return;
    startMarker.key = startKey;

  // CASE 2: Set End Marker and Calculate Route
  } else if (!endMarker) {
  endMarker = L.marker(snappedLatLng, {
    draggable: false,
    icon: L.icon({
      iconUrl: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png',
      iconSize: [32, 32],
      iconAnchor: [16, 32]
    })
  }).addTo(map);

  // Snap both markers to the current filtered trail network
  const snappedStart = turf.nearestPointOnLine(
    turf.featureCollection(filteredFeatures),
    turf.point([startMarker.getLatLng().lng, startMarker.getLatLng().lat])
  );
  const snappedEnd = turf.nearestPointOnLine(
    turf.featureCollection(filteredFeatures),
    turf.point([endMarker.getLatLng().lng, endMarker.getLatLng().lat])
  );

  const snappedStartCoords = [snappedStart.geometry.coordinates[0], snappedStart.geometry.coordinates[1]];
  const snappedEndCoords = [snappedEnd.geometry.coordinates[0], snappedEnd.geometry.coordinates[1]];

  // üîß FIXED: Get startKey from the existing marker
  const startKey = startMarker.key;
  const endKey = addTemporaryNodeToGraph(snappedEnd, graph);

  // Logging graph structure
  console.log("üìå Checking graph connectivity for start and end:");
  console.log("StartKey:", startKey, "Exists:", !!graph[startKey], "Connections:", graph[startKey]);
  console.log("EndKey:", endKey, "Exists:", !!graph[endKey], "Connections:", graph[endKey]);

  const reachable = traverseGraphFrom(startKey, graph);
  console.log("üåê Reachable nodes from startKey:", reachable.size);
  console.log("üîé Does it include endKey?", reachable.has(endKey));

  // Add to graph if needed
  if (!graph[startKey]) {
    graph[startKey] = findNearestGraphConnections(snappedStartCoords);
    nodeCoords[startKey] = snappedStartCoords;
  }
  if (!graph[endKey]) {
    graph[endKey] = findNearestGraphConnections(snappedEndCoords);
    nodeCoords[endKey] = snappedEndCoords;
  }

  // Compute path
  const path = dijkstra(startKey, endKey);

  if (path.length > 0) {
    drawRoute(path);
  } else {
    alert("No path found.");
    console.warn("No path found between", startKey, "and", endKey);
  }
}

  // CASE 3: Reset for next route
   else {
    map.removeLayer(startMarker);
    map.removeLayer(endMarker);
    startMarker = null;
    endMarker = null;
    routeLayers.forEach(l => map.removeLayer(l));
    routeLayers = [];
    document.getElementById("distance").textContent = "-";
    document.getElementById("time").textContent = "-";
    document.getElementById("directions").innerHTML = "";
  }
});



navigator.geolocation.getCurrentPosition(pos => {
  userLocation = [pos.coords.latitude, pos.coords.longitude];
  L.marker(userLocation).addTo(map).bindPopup("You are here").openPopup();
  map.setView(userLocation, 14);
});

fetch('map.geojson')
  .then(res => res.json())
  .then(data => {
    geojsonData = data;
    const dropdown = document.getElementById('season-select');

    dropdown.addEventListener('change', () => {
      console.log("Season dropdown changed to:", dropdown.value);
      buildGraph(geojsonData, dropdown.value);
      displayFilteredTrails(); // <--- ADDED: redraw visible trails
    });

    buildGraph(data, dropdown.value);   // build routing graph
    displayFilteredTrails();            // <--- ADDED: draw trails initially
  })
  .catch(err => console.error("Failed to load map data:", err));

  
</script>

</body>
</html>
